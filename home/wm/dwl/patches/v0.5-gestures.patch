diff --git a/.github/ISSUE_TEMPLATE/bug_report.md b/.github/ISSUE_TEMPLATE/bug_report.md
new file mode 100644
index 0000000..cd9bd8d
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE/bug_report.md
@@ -0,0 +1,17 @@
+---
+name: Bug report
+about: Something in dwl isn't working correctly
+title: ''
+labels: 'A: bug'
+assignees: ''
+
+---
+
+## Info
+dwl version:
+wlroots version:
+## Description
+<!--
+Only report bugs that can be reproduced on the main line
+Report patch issues to their respective authors
+-->
diff --git a/.github/ISSUE_TEMPLATE/enhancement-idea.md b/.github/ISSUE_TEMPLATE/enhancement-idea.md
new file mode 100644
index 0000000..0ac096d
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE/enhancement-idea.md
@@ -0,0 +1,10 @@
+---
+name: Enhancement idea
+about: Suggest a feature or improvement
+title: ''
+labels: 'A: enhancement'
+assignees: ''
+
+---
+
+
diff --git a/Makefile b/Makefile
index a67fdd3..6cde460 100644
--- a/Makefile
+++ b/Makefile
@@ -5,8 +5,8 @@ include config.mk
 
 # flags for compiling
 DWLCPPFLAGS = -I. -DWLR_USE_UNSTABLE -D_POSIX_C_SOURCE=200809L -DVERSION=\"$(VERSION)\" $(XWAYLAND)
-DWLDEVCFLAGS = -g -pedantic -Wall -Wextra -Wdeclaration-after-statement -Wno-unused-parameter -Wshadow -Wunused-macros\
-	-Werror=strict-prototypes -Werror=implicit -Werror=return-type -Werror=incompatible-pointer-types -Wfloat-conversion
+DWLDEVCFLAGS = -g -pedantic -Wall -Wextra -Wdeclaration-after-statement -Wno-unused-parameter -Wno-sign-compare -Wshadow -Wunused-macros\
+	-Werror=strict-prototypes -Werror=implicit -Werror=return-type -Werror=incompatible-pointer-types
 
 # CFLAGS / LDFLAGS
 PKGS      = wlroots wayland-server xkbcommon libinput $(XLIBS)
@@ -16,7 +16,7 @@ LDLIBS    = `$(PKG_CONFIG) --libs $(PKGS)` $(LIBS)
 all: dwl
 dwl: dwl.o util.o
 	$(CC) dwl.o util.o $(LDLIBS) $(LDFLAGS) $(DWLCFLAGS) -o $@
-dwl.o: dwl.c config.mk config.h client.h cursor-shape-v1-protocol.h pointer-constraints-unstable-v1-protocol.h wlr-layer-shell-unstable-v1-protocol.h xdg-shell-protocol.h
+dwl.o: dwl.c config.mk config.h client.h cursor-shape-v1-protocol.h xdg-shell-protocol.h wlr-layer-shell-unstable-v1-protocol.h
 util.o: util.c util.h
 
 # wayland-scanner is a tool which generates C headers and rigging for Wayland
@@ -25,18 +25,15 @@ util.o: util.c util.h
 WAYLAND_SCANNER   = `$(PKG_CONFIG) --variable=wayland_scanner wayland-scanner`
 WAYLAND_PROTOCOLS = `$(PKG_CONFIG) --variable=pkgdatadir wayland-protocols`
 
-cursor-shape-v1-protocol.h:
-	$(WAYLAND_SCANNER) server-header \
-		$(WAYLAND_PROTOCOLS)/staging/cursor-shape/cursor-shape-v1.xml $@
-pointer-constraints-unstable-v1-protocol.h:
+xdg-shell-protocol.h:
 	$(WAYLAND_SCANNER) server-header \
-		$(WAYLAND_PROTOCOLS)/unstable/pointer-constraints/pointer-constraints-unstable-v1.xml $@
+		$(WAYLAND_PROTOCOLS)/stable/xdg-shell/xdg-shell.xml $@
 wlr-layer-shell-unstable-v1-protocol.h:
 	$(WAYLAND_SCANNER) server-header \
 		protocols/wlr-layer-shell-unstable-v1.xml $@
-xdg-shell-protocol.h:
+cursor-shape-v1-protocol.h:
 	$(WAYLAND_SCANNER) server-header \
-		$(WAYLAND_PROTOCOLS)/stable/xdg-shell/xdg-shell.xml $@
+		$(WAYLAND_PROTOCOLS)/staging/cursor-shape/cursor-shape-v1.xml $@
 
 config.h:
 	cp config.def.h $@
@@ -45,7 +42,7 @@ clean:
 
 dist: clean
 	mkdir -p dwl-$(VERSION)
-	cp -R LICENSE* Makefile CHANGELOG.md README.md client.h config.def.h\
+	cp -R LICENSE* Makefile README.md client.h config.def.h\
 		config.mk protocols dwl.1 dwl.c util.c util.h dwl.desktop\
 		dwl-$(VERSION)
 	tar -caf dwl-$(VERSION).tar.gz dwl-$(VERSION)
diff --git a/client.h b/client.h
index 800b867..71c7d76 100644
--- a/client.h
+++ b/client.h
@@ -10,7 +10,7 @@ static inline int
 client_is_x11(Client *c)
 {
 #ifdef XWAYLAND
-	return c->type == X11;
+	return c->type == X11Managed || c->type == X11Unmanaged;
 #endif
 	return 0;
 }
@@ -172,29 +172,14 @@ client_get_parent(Client *c)
 {
 	Client *p = NULL;
 #ifdef XWAYLAND
-    if (client_is_x11(c)) {
-        if (c->surface.xwayland->parent)
-            toplevel_from_wlr_surface(c->surface.xwayland->parent->surface, &p, NULL);
-        return p;
-    }
+	if (client_is_x11(c) && c->surface.xwayland->parent)
+		toplevel_from_wlr_surface(c->surface.xwayland->parent->surface, &p, NULL);
 #endif
 	if (c->surface.xdg->toplevel->parent)
 		toplevel_from_wlr_surface(c->surface.xdg->toplevel->parent->base->surface, &p, NULL);
 	return p;
 }
 
-static inline int
-client_has_children(Client *c)
-{
-#ifdef XWAYLAND
-    if (client_is_x11(c))
-        return !wl_list_empty(&c->surface.xwayland->children);
-#endif
-    /* surface.xdg->link is never empty because it always contains at least the
-     * surface itself. */
-    return wl_list_length(&c->surface.xdg->link) > 1;
-}
-
 static inline const char *
 client_get_title(Client *c)
 {
@@ -285,8 +270,7 @@ static inline int
 client_is_unmanaged(Client *c)
 {
 #ifdef XWAYLAND
-	if (client_is_x11(c))
-		return c->surface.xwayland->override_redirect;
+	return c->type == X11Unmanaged;
 #endif
 	return 0;
 }
@@ -354,10 +338,10 @@ client_set_size(Client *c, uint32_t width, uint32_t height)
 		return 0;
 	}
 #endif
-	if ((int32_t)width == c->surface.xdg->toplevel->current.width
-			&& (int32_t)height == c->surface.xdg->toplevel->current.height)
+	if (width == c->surface.xdg->toplevel->current.width
+			&& height ==c->surface.xdg->toplevel->current.height)
 		return 0;
-	return wlr_xdg_toplevel_set_size(c->surface.xdg->toplevel, (int32_t)width, (int32_t)height);
+	return wlr_xdg_toplevel_set_size(c->surface.xdg->toplevel, width, height);
 }
 
 static inline void
@@ -367,7 +351,7 @@ client_set_tiled(Client *c, uint32_t edges)
 	if (client_is_x11(c))
 		return;
 #endif
-	if (wl_resource_get_version(c->surface.xdg->toplevel->resource)
+	if (wl_resource_get_version(c->surface.xdg->resource)
 			>= XDG_TOPLEVEL_STATE_TILED_RIGHT_SINCE_VERSION) {
 		wlr_xdg_toplevel_set_tiled(c->surface.xdg->toplevel, edges);
 	} else {
@@ -379,8 +363,10 @@ static inline void
 client_set_suspended(Client *c, int suspended)
 {
 #ifdef XWAYLAND
-	if (client_is_x11(c))
+	if (client_is_x11(c)) {
+		wlr_xwayland_surface_set_withdrawn(c->surface.xwayland, suspended);
 		return;
+	}
 #endif
 
 	wlr_xdg_toplevel_set_suspended(c->surface.xdg->toplevel, suspended);
diff --git a/dwl.c b/dwl.c
index bf763df..fd7ab00 100644
--- a/dwl.c
+++ b/dwl.c
@@ -21,6 +21,7 @@
 #include <wlr/types/wlr_data_control_v1.h>
 #include <wlr/types/wlr_data_device.h>
 #include <wlr/types/wlr_drm.h>
+#include <wlr/types/wlr_linux_dmabuf_v1.h>
 #include <wlr/types/wlr_export_dmabuf_v1.h>
 #include <wlr/types/wlr_fractional_scale_v1.h>
 #include <wlr/types/wlr_gamma_control_v1.h>
@@ -28,18 +29,15 @@
 #include <wlr/types/wlr_idle_notify_v1.h>
 #include <wlr/types/wlr_input_device.h>
 #include <wlr/types/wlr_keyboard.h>
-#include <wlr/types/wlr_keyboard_group.h>
 #include <wlr/types/wlr_layer_shell_v1.h>
-#include <wlr/types/wlr_linux_dmabuf_v1.h>
 #include <wlr/types/wlr_output.h>
 #include <wlr/types/wlr_output_layout.h>
 #include <wlr/types/wlr_output_management_v1.h>
 #include <wlr/types/wlr_pointer.h>
-#include <wlr/types/wlr_pointer_constraints_v1.h>
+#include <wlr/types/wlr_pointer_gestures_v1.h>
 #include <wlr/types/wlr_presentation_time.h>
 #include <wlr/types/wlr_primary_selection.h>
 #include <wlr/types/wlr_primary_selection_v1.h>
-#include <wlr/types/wlr_relative_pointer_v1.h>
 #include <wlr/types/wlr_scene.h>
 #include <wlr/types/wlr_screencopy_v1.h>
 #include <wlr/types/wlr_seat.h>
@@ -49,14 +47,12 @@
 #include <wlr/types/wlr_subcompositor.h>
 #include <wlr/types/wlr_viewporter.h>
 #include <wlr/types/wlr_virtual_keyboard_v1.h>
-#include <wlr/types/wlr_virtual_pointer_v1.h>
 #include <wlr/types/wlr_xcursor_manager.h>
 #include <wlr/types/wlr_xdg_activation_v1.h>
 #include <wlr/types/wlr_xdg_decoration_v1.h>
 #include <wlr/types/wlr_xdg_output_v1.h>
 #include <wlr/types/wlr_xdg_shell.h>
 #include <wlr/util/log.h>
-#include <wlr/util/region.h>
 #include <xkbcommon/xkbcommon.h>
 #ifdef XWAYLAND
 #include <wlr/xwayland.h>
@@ -69,7 +65,6 @@
 /* macros */
 #define MAX(A, B)               ((A) > (B) ? (A) : (B))
 #define MIN(A, B)               ((A) < (B) ? (A) : (B))
-#define ROUND(X)                ((int)((X < 0) ? (X - 0.5) : (X + 0.5)))
 #define CLEANMASK(mask)         (mask & ~WLR_MODIFIER_CAPS)
 #define VISIBLEON(C, M)         ((M) && (C)->mon == (M) && ((C)->tags & (M)->tagset[(M)->seltags]))
 #define LENGTH(X)               (sizeof X / sizeof X[0])
@@ -80,12 +75,13 @@
 
 /* enums */
 enum { CurNormal, CurPressed, CurMove, CurResize }; /* cursor */
-enum { XDGShell, LayerShell, X11 }; /* client types */
-enum { LyrBg, LyrBottom, LyrTile, LyrFloat, LyrTop, LyrFS, LyrOverlay, LyrBlock, NUM_LAYERS }; /* scene layers */
+enum { XDGShell, LayerShell, X11Managed, X11Unmanaged }; /* client types */
+enum { LyrBg, LyrBottom, LyrTile, LyrFloat, LyrFS, LyrTop, LyrOverlay, LyrBlock, NUM_LAYERS }; /* scene layers */
 #ifdef XWAYLAND
 enum { NetWMWindowTypeDialog, NetWMWindowTypeSplash, NetWMWindowTypeToolbar,
 	NetWMWindowTypeUtility, NetLast }; /* EWMH atoms */
 #endif
+enum { SWIPE_LEFT, SWIPE_RIGHT, SWIPE_DOWN, SWIPE_UP };
 
 typedef union {
 	int i;
@@ -101,6 +97,14 @@ typedef struct {
 	const Arg arg;
 } Button;
 
+typedef struct {
+	unsigned int mod;
+	unsigned int motion;
+	unsigned int fingers_count;
+	void (*func)(const Arg *);
+	const Arg arg;
+} Gesture;
+
 typedef struct Monitor Monitor;
 typedef struct {
 	/* Must keep these three elements in this order */
@@ -116,7 +120,6 @@ typedef struct {
 		struct wlr_xdg_surface *xdg;
 		struct wlr_xwayland_surface *xwayland;
 	} surface;
-	struct wlr_xdg_toplevel_decoration_v1 *decoration;
 	struct wl_listener commit;
 	struct wl_listener map;
 	struct wl_listener maximize;
@@ -124,8 +127,6 @@ typedef struct {
 	struct wl_listener destroy;
 	struct wl_listener set_title;
 	struct wl_listener fullscreen;
-	struct wl_listener set_decoration_mode;
-	struct wl_listener destroy_decoration;
 	struct wlr_box prev; /* layout-relative, includes border */
 	struct wlr_box bounds;
 #ifdef XWAYLAND
@@ -150,7 +151,7 @@ typedef struct {
 
 typedef struct {
 	struct wl_list link;
-	struct wlr_keyboard_group *wlr_group;
+	struct wlr_keyboard *wlr_keyboard;
 
 	int nsyms;
 	const xkb_keysym_t *keysyms; /* invalid if nsyms == 0 */
@@ -159,7 +160,8 @@ typedef struct {
 
 	struct wl_listener modifiers;
 	struct wl_listener key;
-} KeyboardGroup;
+	struct wl_listener destroy;
+} Keyboard;
 
 typedef struct {
 	/* Must keep these three elements in this order */
@@ -196,12 +198,12 @@ struct Monitor {
 	struct wlr_session_lock_surface_v1 *lock_surface;
 	struct wlr_box m; /* monitor area, layout-relative */
 	struct wlr_box w; /* window area, layout-relative */
-	struct wl_list layers[4]; /* LayerSurface.link */
+	struct wl_list layers[4]; /* LayerSurface::link */
 	const Layout *lt[2];
 	unsigned int seltags;
 	unsigned int sellt;
 	uint32_t tagset[2];
-	float mfact;
+	double mfact;
 	int gamma_lut_changed;
 	int nmaster;
 	char ltsymbol[16];
@@ -217,11 +219,6 @@ typedef struct {
 	int x, y;
 } MonitorRule;
 
-typedef struct {
-	struct wlr_pointer_constraint_v1 *constraint;
-	struct wl_listener destroy;
-} PointerConstraint;
-
 typedef struct {
 	const char *id;
 	const char *title;
@@ -248,9 +245,17 @@ static void arrangelayer(Monitor *m, struct wl_list *list,
 static void arrangelayers(Monitor *m);
 static void axisnotify(struct wl_listener *listener, void *data);
 static void buttonpress(struct wl_listener *listener, void *data);
+static int ongesture(struct wlr_pointer_swipe_end_event *event);
+static void swipe_begin(struct wl_listener *listener, void *data);
+static void swipe_update(struct wl_listener *listener, void *data);
+static void swipe_end(struct wl_listener *listener, void *data);
+static void pinch_begin(struct wl_listener *listener, void *data);
+static void pinch_update(struct wl_listener *listener, void *data);
+static void pinch_end(struct wl_listener *listener, void *data);
 static void chvt(const Arg *arg);
 static void checkidleinhibitor(struct wlr_surface *exclude);
 static void cleanup(void);
+static void cleanupkeyboard(struct wl_listener *listener, void *data);
 static void cleanupmon(struct wl_listener *listener, void *data);
 static void closemon(Monitor *m);
 static void commitlayersurfacenotify(struct wl_listener *listener, void *data);
@@ -263,18 +268,13 @@ static void createlocksurface(struct wl_listener *listener, void *data);
 static void createmon(struct wl_listener *listener, void *data);
 static void createnotify(struct wl_listener *listener, void *data);
 static void createpointer(struct wlr_pointer *pointer);
-static void createpointerconstraint(struct wl_listener *listener, void *data);
-static void cursorconstrain(struct wlr_pointer_constraint_v1 *constraint);
 static void cursorframe(struct wl_listener *listener, void *data);
-static void cursorwarptohint(void);
-static void destroydecoration(struct wl_listener *listener, void *data);
 static void destroydragicon(struct wl_listener *listener, void *data);
 static void destroyidleinhibitor(struct wl_listener *listener, void *data);
 static void destroylayersurfacenotify(struct wl_listener *listener, void *data);
 static void destroylock(SessionLock *lock, int unlocked);
 static void destroylocksurface(struct wl_listener *listener, void *data);
 static void destroynotify(struct wl_listener *listener, void *data);
-static void destroypointerconstraint(struct wl_listener *listener, void *data);
 static void destroysessionlock(struct wl_listener *listener, void *data);
 static void destroysessionmgr(struct wl_listener *listener, void *data);
 static Monitor *dirtomon(enum wlr_direction dir);
@@ -297,8 +297,7 @@ static void mapnotify(struct wl_listener *listener, void *data);
 static void maximizenotify(struct wl_listener *listener, void *data);
 static void monocle(Monitor *m);
 static void motionabsolute(struct wl_listener *listener, void *data);
-static void motionnotify(uint32_t time, struct wlr_input_device *device, double sx,
-		double sy, double sx_unaccel, double sy_unaccel);
+static void motionnotify(uint32_t time);
 static void motionrelative(struct wl_listener *listener, void *data);
 static void moveresize(const Arg *arg);
 static void outputmgrapply(struct wl_listener *listener, void *data);
@@ -309,7 +308,6 @@ static void pointerfocus(Client *c, struct wlr_surface *surface,
 static void printstatus(void);
 static void quit(const Arg *arg);
 static void rendermon(struct wl_listener *listener, void *data);
-static void requestdecorationmode(struct wl_listener *listener, void *data);
 static void requeststartdrag(struct wl_listener *listener, void *data);
 static void requestmonstate(struct wl_listener *listener, void *data);
 static void resize(Client *c, struct wlr_box geo, int interact);
@@ -342,7 +340,6 @@ static void updatetitle(struct wl_listener *listener, void *data);
 static void urgent(struct wl_listener *listener, void *data);
 static void view(const Arg *arg);
 static void virtualkeyboard(struct wl_listener *listener, void *data);
-static void virtualpointer(struct wl_listener *listener, void *data);
 static Monitor *xytomon(double x, double y);
 static void xytonode(double x, double y, struct wlr_surface **psurface,
 		Client **pc, LayerSurface **pl, double *nx, double *ny);
@@ -376,26 +373,19 @@ static struct wlr_layer_shell_v1 *layer_shell;
 static struct wlr_output_manager_v1 *output_mgr;
 static struct wlr_gamma_control_manager_v1 *gamma_control_mgr;
 static struct wlr_virtual_keyboard_manager_v1 *virtual_keyboard_mgr;
-static struct wlr_virtual_pointer_manager_v1 *virtual_pointer_mgr;
 static struct wlr_cursor_shape_manager_v1 *cursor_shape_mgr;
-
-static struct wlr_pointer_constraints_v1 *pointer_constraints;
-static struct wlr_relative_pointer_manager_v1 *relative_pointer_mgr;
-static struct wlr_pointer_constraint_v1 *active_constraint;
+static struct wlr_pointer_gestures_v1 *pointer_gestures;
 
 static struct wlr_cursor *cursor;
 static struct wlr_xcursor_manager *cursor_mgr;
 
-static struct wlr_scene_rect *root_bg;
 static struct wlr_session_lock_manager_v1 *session_lock_mgr;
 static struct wlr_scene_rect *locked_bg;
 static struct wlr_session_lock_v1 *cur_lock;
 static struct wl_listener lock_listener = {.notify = locksession};
 
 static struct wlr_seat *seat;
-static KeyboardGroup kb_group = {0};
-static KeyboardGroup vkb_group = {0};
-static struct wlr_surface *held_grab;
+static struct wl_list keyboards;
 static unsigned int cursor_mode;
 static Client *grabc;
 static int grabcx, grabcy; /* client-relative */
@@ -405,6 +395,10 @@ static struct wlr_box sgeom;
 static struct wl_list mons;
 static Monitor *selmon;
 
+static uint32_t swipe_fingers = 0;
+static double swipe_dx = 0;
+static double swipe_dy = 0;
+
 #ifdef XWAYLAND
 static void activatex11(struct wl_listener *listener, void *data);
 static void associatex11(struct wl_listener *listener, void *data);
@@ -424,21 +418,23 @@ static xcb_atom_t netatom[NetLast];
 /* attempt to encapsulate suck into one file */
 #include "client.h"
 
+static const unsigned int abzsquare = swipe_min_threshold * swipe_min_threshold;
+
 /* function implementations */
 void
 applybounds(Client *c, struct wlr_box *bbox)
 {
 	/* set minimum possible */
-	c->geom.width = MAX(1 + 2 * (int)c->bw, c->geom.width);
-	c->geom.height = MAX(1 + 2 * (int)c->bw, c->geom.height);
+	c->geom.width = MAX(1, c->geom.width);
+	c->geom.height = MAX(1, c->geom.height);
 
 	if (c->geom.x >= bbox->x + bbox->width)
 		c->geom.x = bbox->x + bbox->width - c->geom.width;
 	if (c->geom.y >= bbox->y + bbox->height)
 		c->geom.y = bbox->y + bbox->height - c->geom.height;
-	if (c->geom.x + c->geom.width + 2 * (int)c->bw <= bbox->x)
+	if (c->geom.x + c->geom.width + 2 * c->bw <= bbox->x)
 		c->geom.x = bbox->x;
-	if (c->geom.y + c->geom.height + 2 * (int)c->bw <= bbox->y)
+	if (c->geom.y + c->geom.height + 2 * c->bw <= bbox->y)
 		c->geom.y = bbox->y;
 }
 
@@ -447,8 +443,7 @@ applyrules(Client *c)
 {
 	/* rule matching */
 	const char *appid, *title;
-	uint32_t newtags = 0;
-	int i;
+	uint32_t i, newtags = 0;
 	const Rule *r;
 	Monitor *mon = selmon, *m;
 
@@ -464,12 +459,12 @@ applyrules(Client *c)
 			c->isfloating = r->isfloating;
 			newtags |= r->tags;
 			i = 0;
-			wl_list_for_each(m, &mons, link) {
+			wl_list_for_each(m, &mons, link)
 				if (r->monitor == i++)
 					mon = m;
-			}
 		}
 	}
+	wlr_scene_node_reparent(&c->scene->node, layers[c->isfloating ? LyrFloat : LyrTile]);
 	setmon(c, mon, newtags);
 }
 
@@ -477,10 +472,6 @@ void
 arrange(Monitor *m)
 {
 	Client *c;
-
-	if (!m->wlr_output->enabled)
-		return;
-
 	wl_list_for_each(c, &clients, link) {
 		if (c->mon == m) {
 			wlr_scene_node_set_enabled(&c->scene->node, VISIBLEON(c, m));
@@ -495,26 +486,28 @@ arrange(Monitor *m)
 
 	if (m->lt[m->sellt]->arrange)
 		m->lt[m->sellt]->arrange(m);
-	motionnotify(0, NULL, 0, 0, 0, 0);
+	motionnotify(0);
 	checkidleinhibitor(NULL);
 }
 
 void
 arrangelayer(Monitor *m, struct wl_list *list, struct wlr_box *usable_area, int exclusive)
 {
-	LayerSurface *l;
+	LayerSurface *layersurface;
 	struct wlr_box full_area = m->m;
 
-	wl_list_for_each(l, list, link) {
-		struct wlr_layer_surface_v1 *layer_surface = l->layer_surface;
+	wl_list_for_each(layersurface, list, link) {
+		struct wlr_layer_surface_v1 *wlr_layer_surface = layersurface->layer_surface;
+		struct wlr_layer_surface_v1_state *state = &wlr_layer_surface->current;
 
-		if (exclusive != (layer_surface->current.exclusive_zone > 0))
+		if (exclusive != (state->exclusive_zone > 0))
 			continue;
 
-		wlr_scene_layer_surface_v1_configure(l->scene_layer, &full_area, usable_area);
-		wlr_scene_node_set_position(&l->popups->node, l->scene->node.x, l->scene->node.y);
-		l->geom.x = l->scene->node.x;
-		l->geom.y = l->scene->node.y;
+		wlr_scene_layer_surface_v1_configure(layersurface->scene_layer, &full_area, usable_area);
+		wlr_scene_node_set_position(&layersurface->popups->node,
+				layersurface->scene->node.x, layersurface->scene->node.y);
+		layersurface->geom.x = layersurface->scene->node.x;
+		layersurface->geom.y = layersurface->scene->node.y;
 	}
 }
 
@@ -523,11 +516,11 @@ arrangelayers(Monitor *m)
 {
 	int i;
 	struct wlr_box usable_area = m->m;
-	LayerSurface *l;
 	uint32_t layers_above_shell[] = {
 		ZWLR_LAYER_SHELL_V1_LAYER_OVERLAY,
 		ZWLR_LAYER_SHELL_V1_LAYER_TOP,
 	};
+	LayerSurface *layersurface;
 	if (!m->wlr_output->enabled)
 		return;
 
@@ -535,7 +528,7 @@ arrangelayers(Monitor *m)
 	for (i = 3; i >= 0; i--)
 		arrangelayer(m, &m->layers[i], &usable_area, 1);
 
-	if (!wlr_box_equal(&usable_area, &m->w)) {
+	if (memcmp(&usable_area, &m->w, sizeof(struct wlr_box))) {
 		m->w = usable_area;
 		arrange(m);
 	}
@@ -545,15 +538,17 @@ arrangelayers(Monitor *m)
 		arrangelayer(m, &m->layers[i], &usable_area, 0);
 
 	/* Find topmost keyboard interactive layer, if such a layer exists */
-	for (i = 0; i < (int)LENGTH(layers_above_shell); i++) {
-		wl_list_for_each_reverse(l, &m->layers[layers_above_shell[i]], link) {
-			if (locked || !l->layer_surface->current.keyboard_interactive || !l->mapped)
-				continue;
-			/* Deactivate the focused client. */
-			focusclient(NULL, 0);
-			exclusive_focus = l;
-			client_notify_enter(l->layer_surface->surface, wlr_seat_get_keyboard(seat));
-			return;
+	for (i = 0; i < LENGTH(layers_above_shell); i++) {
+		wl_list_for_each_reverse(layersurface,
+				&m->layers[layers_above_shell[i]], link) {
+			if (!locked && layersurface->layer_surface->current.keyboard_interactive
+					&& layersurface->mapped) {
+				/* Deactivate the focused client. */
+				focusclient(NULL, 0);
+				exclusive_focus = layersurface;
+				client_notify_enter(layersurface->layer_surface->surface, wlr_seat_get_keyboard(seat));
+				return;
+			}
 		}
 	}
 }
@@ -587,7 +582,6 @@ buttonpress(struct wl_listener *listener, void *data)
 	switch (event->state) {
 	case WLR_BUTTON_PRESSED:
 		cursor_mode = CurPressed;
-		held_grab = seat->pointer_state.focused_surface;
 		if (locked)
 			break;
 
@@ -607,7 +601,6 @@ buttonpress(struct wl_listener *listener, void *data)
 		}
 		break;
 	case WLR_BUTTON_RELEASED:
-		held_grab = NULL;
 		/* If you released any buttons, we exit interactive move/resize mode. */
 		/* TODO should reset to the pointer focus's current setcursor */
 		if (!locked && cursor_mode != CurNormal && cursor_mode != CurPressed) {
@@ -628,6 +621,146 @@ buttonpress(struct wl_listener *listener, void *data)
 			event->time_msec, event->button, event->state);
 }
 
+void
+swipe_begin(struct wl_listener *listener, void *data)
+{
+	struct wlr_pointer_swipe_begin_event *event = data;
+
+	swipe_fingers = event->fingers;
+	// Reset swipe distance at the beginning of a swipe
+	swipe_dx = 0;
+	swipe_dy = 0;
+
+	// Forward swipe begin event to client
+	wlr_pointer_gestures_v1_send_swipe_begin(
+		pointer_gestures, 
+		seat,
+		event->time_msec,
+		event->fingers
+	);
+}
+
+void
+swipe_update(struct wl_listener *listener, void *data)
+{
+	struct wlr_pointer_swipe_update_event *event = data;
+
+	swipe_fingers = event->fingers;
+	// Accumulate swipe distance
+	swipe_dx += event->dx;
+	swipe_dy += event->dy;
+
+	// Forward swipe update event to client
+	wlr_pointer_gestures_v1_send_swipe_update(
+		pointer_gestures, 
+		seat,
+		event->time_msec,
+		event->dx,
+		event->dy
+	);
+}
+
+int
+ongesture(struct wlr_pointer_swipe_end_event *event)
+{
+	struct wlr_keyboard *keyboard;
+	uint32_t mods;
+	const Gesture *g;
+	unsigned int motion;
+	unsigned int adx = fabs(swipe_dx);
+	unsigned int ady = fabs(swipe_dy);
+	int handled = 0;
+
+	if (event->cancelled) {
+		return handled;
+	}
+
+	// Require absolute distance movement beyond a small thresh-hold
+	if (adx * adx + ady * ady < abzsquare) {
+		return handled;
+	}
+
+	if (adx > ady) {
+		motion = swipe_dx < 0 ? SWIPE_LEFT : SWIPE_RIGHT;
+	} else {
+		motion = swipe_dy < 0 ? SWIPE_UP : SWIPE_DOWN;
+	}
+
+	keyboard = wlr_seat_get_keyboard(seat);
+	mods = keyboard ? wlr_keyboard_get_modifiers(keyboard) : 0;
+	for (g = gestures; g < END(gestures); g++) {
+		if (CLEANMASK(mods) == CLEANMASK(g->mod) &&
+			 swipe_fingers == g->fingers_count &&
+			 motion == g->motion && g->func) {
+			g->func(&g->arg);
+			handled = 1;
+		}
+	}
+	return handled;
+}
+
+void
+swipe_end(struct wl_listener *listener, void *data)
+{
+	struct wlr_pointer_swipe_end_event *event = data;
+
+	// TODO: should we stop here if the event has been handled?
+	ongesture(event);
+
+	// Forward swipe end event to client
+	wlr_pointer_gestures_v1_send_swipe_end(
+		pointer_gestures, 
+		seat,
+		event->time_msec,
+		event->cancelled
+	);
+}
+
+void
+pinch_begin(struct wl_listener *listener, void *data)
+{
+	struct wlr_pointer_pinch_begin_event *event = data;
+
+	// Forward pinch begin event to client
+	wlr_pointer_gestures_v1_send_pinch_begin(
+		pointer_gestures, 
+		seat,
+		event->time_msec,
+		event->fingers
+	);
+}
+
+void
+pinch_update(struct wl_listener *listener, void *data)
+{
+	struct wlr_pointer_pinch_update_event *event = data;
+
+	// Forward pinch update event to client
+	wlr_pointer_gestures_v1_send_pinch_update(
+		pointer_gestures,
+		seat,
+		event->time_msec,
+		event->dx,
+		event->dy,
+		event->scale,
+		event->rotation
+	);
+}
+
+void
+pinch_end(struct wl_listener *listener, void *data)
+{
+	struct wlr_pointer_pinch_end_event *event = data;
+
+	// Forward pinch end event to client
+	wlr_pointer_gestures_v1_send_pinch_end(
+		pointer_gestures,
+		seat,
+		event->time_msec,
+		event->cancelled
+	);
+}
+
 void
 chvt(const Arg *arg)
 {
@@ -666,40 +799,45 @@ cleanup(void)
 	}
 	wlr_xcursor_manager_destroy(cursor_mgr);
 	wlr_output_layout_destroy(output_layout);
-
-	/* Remove event source that use the dpy event loop before destroying dpy */
-	wl_event_source_remove(kb_group.key_repeat_source);
-	wl_event_source_remove(vkb_group.key_repeat_source);
-
 	wl_display_destroy(dpy);
 	/* Destroy after the wayland display (when the monitors are already destroyed)
 	   to avoid destroying them with an invalid scene output. */
 	wlr_scene_node_destroy(&scene->tree.node);
 }
 
+void
+cleanupkeyboard(struct wl_listener *listener, void *data)
+{
+	Keyboard *kb = wl_container_of(listener, kb, destroy);
+
+	wl_event_source_remove(kb->key_repeat_source);
+	wl_list_remove(&kb->link);
+	wl_list_remove(&kb->modifiers.link);
+	wl_list_remove(&kb->key.link);
+	wl_list_remove(&kb->destroy.link);
+	free(kb);
+}
+
 void
 cleanupmon(struct wl_listener *listener, void *data)
 {
 	Monitor *m = wl_container_of(listener, m, destroy);
 	LayerSurface *l, *tmp;
-	size_t i;
+	int i;
 
-	/* m->layers[i] are intentionally not unlinked */
-	for (i = 0; i < LENGTH(m->layers); i++) {
+	for (i = 0; i <= ZWLR_LAYER_SHELL_V1_LAYER_OVERLAY; i++)
 		wl_list_for_each_safe(l, tmp, &m->layers[i], link)
 			wlr_layer_surface_v1_destroy(l->layer_surface);
-	}
 
 	wl_list_remove(&m->destroy.link);
 	wl_list_remove(&m->frame.link);
 	wl_list_remove(&m->link);
-	wl_list_remove(&m->request_state.link);
 	m->wlr_output->data = NULL;
 	wlr_output_layout_remove(output_layout, m->wlr_output);
 	wlr_scene_output_destroy(m->scene_output);
+	wlr_scene_node_destroy(&m->fullscreen_bg->node);
 
 	closemon(m);
-	wlr_scene_node_destroy(&m->fullscreen_bg->node);
 	free(m);
 }
 
@@ -709,10 +847,10 @@ closemon(Monitor *m)
 	/* update selmon if needed and
 	 * move closed monitor's clients to the focused one */
 	Client *c;
-	int i = 0, nmons = wl_list_length(&mons);
-	if (!nmons) {
+	if (wl_list_empty(&mons)) {
 		selmon = NULL;
 	} else if (m == selmon) {
+		int nmons = wl_list_length(&mons), i = 0;
 		do /* don't switch to disabled mons */
 			selmon = wl_container_of(mons.next, selmon, link);
 		while (!selmon->wlr_output->enabled && i++ < nmons);
@@ -721,7 +859,7 @@ closemon(Monitor *m)
 	wl_list_for_each(c, &clients, link) {
 		if (c->isfloating && c->geom.x > m->m.width)
 			resize(c, (struct wlr_box){.x = c->geom.x - m->w.width, .y = c->geom.y,
-					.width = c->geom.width, .height = c->geom.height}, 0);
+				.width = c->geom.width, .height = c->geom.height}, 0);
 		if (c->mon == m)
 			setmon(c, selmon, c->tags);
 	}
@@ -732,23 +870,32 @@ closemon(Monitor *m)
 void
 commitlayersurfacenotify(struct wl_listener *listener, void *data)
 {
-	LayerSurface *l = wl_container_of(listener, l, surface_commit);
-	struct wlr_layer_surface_v1 *layer_surface = l->layer_surface;
-	struct wlr_scene_tree *scene_layer = layers[layermap[layer_surface->current.layer]];
+	LayerSurface *layersurface = wl_container_of(listener, layersurface, surface_commit);
+	struct wlr_layer_surface_v1 *wlr_layer_surface = layersurface->layer_surface;
+	struct wlr_output *wlr_output = wlr_layer_surface->output;
+	struct wlr_scene_tree *layer = layers[layermap[wlr_layer_surface->current.layer]];
 
-	if (layer_surface->current.committed == 0 && l->mapped == layer_surface->surface->mapped)
+	/* For some reason this layersurface have no monitor, this can be because
+	 * its monitor has just been destroyed */
+	if (!wlr_output || !(layersurface->mon = wlr_output->data))
 		return;
-	l->mapped = layer_surface->surface->mapped;
-
-	if (scene_layer != l->scene->node.parent) {
-		wlr_scene_node_reparent(&l->scene->node, scene_layer);
-		wl_list_remove(&l->link);
-		wl_list_insert(&l->mon->layers[layer_surface->current.layer], &l->link);
-		wlr_scene_node_reparent(&l->popups->node, (layer_surface->current.layer
-				< ZWLR_LAYER_SHELL_V1_LAYER_TOP ? layers[LyrTop] : scene_layer));
+
+	if (layer != layersurface->scene->node.parent) {
+		wlr_scene_node_reparent(&layersurface->scene->node, layer);
+		wlr_scene_node_reparent(&layersurface->popups->node, layer);
+		wl_list_remove(&layersurface->link);
+		wl_list_insert(&layersurface->mon->layers[wlr_layer_surface->current.layer],
+				&layersurface->link);
 	}
+	if (wlr_layer_surface->current.layer < ZWLR_LAYER_SHELL_V1_LAYER_TOP)
+		wlr_scene_node_reparent(&layersurface->popups->node, layers[LyrTop]);
 
-	arrangelayers(l->mon);
+	if (wlr_layer_surface->current.committed == 0
+			&& layersurface->mapped == wlr_layer_surface->surface->mapped)
+		return;
+	layersurface->mapped = wlr_layer_surface->surface->mapped;
+
+	arrangelayers(layersurface->mon);
 }
 
 void
@@ -756,7 +903,7 @@ commitnotify(struct wl_listener *listener, void *data)
 {
 	Client *c = wl_container_of(listener, c, commit);
 
-	if (client_surface(c)->mapped && c->mon)
+	if (client_surface(c)->mapped)
 		resize(c, c->geom, (c->isfloating && !c->isfullscreen));
 
 	/* mark a pending resize as completed */
@@ -767,14 +914,8 @@ commitnotify(struct wl_listener *listener, void *data)
 void
 createdecoration(struct wl_listener *listener, void *data)
 {
-	struct wlr_xdg_toplevel_decoration_v1 *deco = data;
-	Client *c = deco->toplevel->base->data;
-	c->decoration = deco;
-
-	LISTEN(&deco->events.request_mode, &c->set_decoration_mode, requestdecorationmode);
-	LISTEN(&deco->events.destroy, &c->destroy_decoration, destroydecoration);
-
-	requestdecorationmode(&c->set_decoration_mode, deco);
+	struct wlr_xdg_toplevel_decoration_v1 *dec = data;
+	wlr_xdg_toplevel_decoration_v1_set_mode(dec, WLR_XDG_TOPLEVEL_DECORATION_V1_MODE_SERVER_SIDE);
 }
 
 void
@@ -789,55 +930,83 @@ createidleinhibitor(struct wl_listener *listener, void *data)
 void
 createkeyboard(struct wlr_keyboard *keyboard)
 {
-	/* Set the keymap to match the group keymap */
-	wlr_keyboard_set_keymap(keyboard, kb_group.wlr_group->keyboard.keymap);
+	struct xkb_context *context;
+	struct xkb_keymap *keymap;
+	Keyboard *kb = keyboard->data = ecalloc(1, sizeof(*kb));
+	kb->wlr_keyboard = keyboard;
+
+	/* Prepare an XKB keymap and assign it to the keyboard. */
+	context = xkb_context_new(XKB_CONTEXT_NO_FLAGS);
+	keymap = xkb_keymap_new_from_names(context, &xkb_rules,
+		XKB_KEYMAP_COMPILE_NO_FLAGS);
+	if (!keymap)
+		die("createkeyboard: failed to compile keymap");
+
+	wlr_keyboard_set_keymap(keyboard, keymap);
+	xkb_keymap_unref(keymap);
+	xkb_context_unref(context);
 	wlr_keyboard_set_repeat_info(keyboard, repeat_rate, repeat_delay);
 
-	/* Add the new keyboard to the group */
-	wlr_keyboard_group_add_keyboard(kb_group.wlr_group, keyboard);
+	/* Here we set up listeners for keyboard events. */
+	LISTEN(&keyboard->events.modifiers, &kb->modifiers, keypressmod);
+	LISTEN(&keyboard->events.key, &kb->key, keypress);
+	LISTEN(&keyboard->base.events.destroy, &kb->destroy, cleanupkeyboard);
+
+	wlr_seat_set_keyboard(seat, keyboard);
+
+	kb->key_repeat_source = wl_event_loop_add_timer(
+			wl_display_get_event_loop(dpy), keyrepeat, kb);
+
+	/* And add the keyboard to our list of keyboards */
+	wl_list_insert(&keyboards, &kb->link);
 }
 
 void
 createlayersurface(struct wl_listener *listener, void *data)
 {
-	struct wlr_layer_surface_v1 *layer_surface = data;
-	LayerSurface *l;
-	struct wlr_surface *surface = layer_surface->surface;
-	struct wlr_scene_tree *scene_layer = layers[layermap[layer_surface->pending.layer]];
+	struct wlr_layer_surface_v1 *wlr_layer_surface = data;
+	LayerSurface *layersurface;
 	struct wlr_layer_surface_v1_state old_state;
+	struct wlr_scene_tree *l = layers[layermap[wlr_layer_surface->pending.layer]];
+
+	if (!wlr_layer_surface->output)
+		wlr_layer_surface->output = selmon ? selmon->wlr_output : NULL;
 
-	if (!layer_surface->output
-			&& !(layer_surface->output = selmon ? selmon->wlr_output : NULL)) {
-		wlr_layer_surface_v1_destroy(layer_surface);
+	if (!wlr_layer_surface->output) {
+		wlr_layer_surface_v1_destroy(wlr_layer_surface);
 		return;
 	}
 
-	l = layer_surface->data = ecalloc(1, sizeof(*l));
-	l->type = LayerShell;
-	LISTEN(&surface->events.commit, &l->surface_commit, commitlayersurfacenotify);
-	LISTEN(&surface->events.map, &l->map, maplayersurfacenotify);
-	LISTEN(&surface->events.unmap, &l->unmap, unmaplayersurfacenotify);
-	LISTEN(&layer_surface->events.destroy, &l->destroy, destroylayersurfacenotify);
+	layersurface = wlr_layer_surface->data = ecalloc(1, sizeof(LayerSurface));
+	layersurface->type = LayerShell;
+	LISTEN(&wlr_layer_surface->surface->events.commit,
+			&layersurface->surface_commit, commitlayersurfacenotify);
+	LISTEN(&wlr_layer_surface->events.destroy, &layersurface->destroy,
+			destroylayersurfacenotify);
+	LISTEN(&wlr_layer_surface->surface->events.map, &layersurface->map,
+			maplayersurfacenotify);
+	LISTEN(&wlr_layer_surface->surface->events.unmap, &layersurface->unmap,
+			unmaplayersurfacenotify);
 
-	l->layer_surface = layer_surface;
-	l->mon = layer_surface->output->data;
-	l->scene_layer = wlr_scene_layer_surface_v1_create(scene_layer, layer_surface);
-	l->scene = l->scene_layer->tree;
-	l->popups = surface->data = wlr_scene_tree_create(layer_surface->current.layer
-			< ZWLR_LAYER_SHELL_V1_LAYER_TOP ? layers[LyrTop] : scene_layer);
-	l->scene->node.data = l->popups->node.data = l;
+	layersurface->layer_surface = wlr_layer_surface;
+	layersurface->mon = wlr_layer_surface->output->data;
+	layersurface->scene_layer = wlr_scene_layer_surface_v1_create(l, wlr_layer_surface);
+	layersurface->scene = layersurface->scene_layer->tree;
+	layersurface->popups = wlr_layer_surface->surface->data = wlr_scene_tree_create(l);
 
-	wl_list_insert(&l->mon->layers[layer_surface->pending.layer],&l->link);
-	wlr_surface_send_enter(surface, layer_surface->output);
+	layersurface->scene->node.data = layersurface;
+
+	wl_list_insert(&layersurface->mon->layers[wlr_layer_surface->pending.layer],
+			&layersurface->link);
 
 	/* Temporarily set the layer's current state to pending
 	 * so that we can easily arrange it
 	 */
-	old_state = layer_surface->current;
-	layer_surface->current = layer_surface->pending;
-	l->mapped = 1;
-	arrangelayers(l->mon);
-	layer_surface->current = old_state;
+	old_state = wlr_layer_surface->current;
+	wlr_layer_surface->current = wlr_layer_surface->pending;
+	layersurface->mapped = 1;
+	arrangelayers(layersurface->mon);
+	wlr_layer_surface->current = old_state;
 }
 
 void
@@ -846,8 +1015,8 @@ createlocksurface(struct wl_listener *listener, void *data)
 	SessionLock *lock = wl_container_of(listener, lock, new_surface);
 	struct wlr_session_lock_surface_v1 *lock_surface = data;
 	Monitor *m = lock_surface->output->data;
-	struct wlr_scene_tree *scene_tree = lock_surface->surface->data
-			= wlr_scene_subsurface_tree_create(lock->scene, lock_surface->surface);
+	struct wlr_scene_tree *scene_tree = lock_surface->surface->data =
+		wlr_scene_subsurface_tree_create(lock->scene, lock_surface->surface);
 	m->lock_surface = lock_surface;
 
 	wlr_scene_node_set_position(&scene_tree->node, m->m.x, m->m.y);
@@ -867,32 +1036,24 @@ createmon(struct wl_listener *listener, void *data)
 	struct wlr_output *wlr_output = data;
 	const MonitorRule *r;
 	size_t i;
-	struct wlr_output_state state;
-	Monitor *m;
-
-	if (!wlr_output_init_render(wlr_output, alloc, drw))
-		return;
-
-	m = wlr_output->data = ecalloc(1, sizeof(*m));
+	Monitor *m = wlr_output->data = ecalloc(1, sizeof(*m));
 	m->wlr_output = wlr_output;
 
-	for (i = 0; i < LENGTH(m->layers); i++)
-		wl_list_init(&m->layers[i]);
+	wlr_output_init_render(wlr_output, alloc, drw);
 
-	wlr_output_state_init(&state);
 	/* Initialize monitor state using configured rules */
+	for (i = 0; i < LENGTH(m->layers); i++)
+		wl_list_init(&m->layers[i]);
 	m->tagset[0] = m->tagset[1] = 1;
 	for (r = monrules; r < END(monrules); r++) {
 		if (!r->name || strstr(wlr_output->name, r->name)) {
-			m->m.x = r->x;
-			m->m.y = r->y;
 			m->mfact = r->mfact;
 			m->nmaster = r->nmaster;
-			m->lt[0] = r->lt;
-			m->lt[1] = &layouts[LENGTH(layouts) > 1 && r->lt != &layouts[1]];
-			strncpy(m->ltsymbol, m->lt[m->sellt]->symbol, LENGTH(m->ltsymbol));
-			wlr_output_state_set_scale(&state, r->scale);
-			wlr_output_state_set_transform(&state, r->rr);
+			wlr_output_set_scale(wlr_output, r->scale);
+			m->lt[0] = m->lt[1] = r->lt;
+			wlr_output_set_transform(wlr_output, r->rr);
+			m->m.x = r->x;
+			m->m.y = r->y;
 			break;
 		}
 	}
@@ -901,16 +1062,16 @@ createmon(struct wl_listener *listener, void *data)
 	 * monitor supports only a specific set of modes. We just pick the
 	 * monitor's preferred mode; a more sophisticated compositor would let
 	 * the user configure it. */
-	wlr_output_state_set_mode(&state, wlr_output_preferred_mode(wlr_output));
+	wlr_output_set_mode(wlr_output, wlr_output_preferred_mode(wlr_output));
 
 	/* Set up event listeners */
 	LISTEN(&wlr_output->events.frame, &m->frame, rendermon);
 	LISTEN(&wlr_output->events.destroy, &m->destroy, cleanupmon);
 	LISTEN(&wlr_output->events.request_state, &m->request_state, requestmonstate);
 
-	wlr_output_state_set_enabled(&state, 1);
-	wlr_output_commit_state(wlr_output, &state);
-	wlr_output_state_finish(&state);
+	wlr_output_enable(wlr_output, 1);
+	if (!wlr_output_commit(wlr_output))
+		return;
 
 	wl_list_insert(&mons, &m->link);
 	printstatus();
@@ -938,6 +1099,7 @@ createmon(struct wl_listener *listener, void *data)
 		wlr_output_layout_add_auto(output_layout, wlr_output);
 	else
 		wlr_output_layout_add(output_layout, wlr_output, m->m.x, m->m.y);
+	strncpy(m->ltsymbol, m->lt[m->sellt]->symbol, LENGTH(m->ltsymbol));
 }
 
 void
@@ -953,18 +1115,18 @@ createnotify(struct wl_listener *listener, void *data)
 	LayerSurface *l = NULL;
 
 	if (xdg_surface->role == WLR_XDG_SURFACE_ROLE_POPUP) {
-		struct wlr_xdg_popup *popup = xdg_surface->popup;
 		struct wlr_box box;
-		if (toplevel_from_wlr_surface(popup->base->surface, &c, &l) < 0)
+		int type = toplevel_from_wlr_surface(xdg_surface->surface, &c, &l);
+		if (!xdg_surface->popup->parent || type < 0)
 			return;
-		popup->base->surface->data = wlr_scene_xdg_surface_create(
-				popup->parent->data, popup->base);
+		xdg_surface->surface->data = wlr_scene_xdg_surface_create(
+				xdg_surface->popup->parent->data, xdg_surface);
 		if ((l && !l->mon) || (c && !c->mon))
 			return;
-		box = l ? l->mon->m : c->mon->w;
-		box.x -= (l ? l->geom.x : c->geom.x);
-		box.y -= (l ? l->geom.y : c->geom.y);
-		wlr_xdg_popup_unconstrain_from_box(popup, &box);
+		box = type == LayerShell ? l->mon->m : c->mon->w;
+		box.x -= (type == LayerShell ? l->geom.x : c->geom.x);
+		box.y -= (type == LayerShell ? l->geom.y : c->geom.y);
+		wlr_xdg_popup_unconstrain_from_box(xdg_surface->popup, &box);
 		return;
 	} else if (xdg_surface->role == WLR_XDG_SURFACE_ROLE_NONE)
 		return;
@@ -977,83 +1139,61 @@ createnotify(struct wl_listener *listener, void *data)
 	wlr_xdg_toplevel_set_wm_capabilities(xdg_surface->toplevel,
 			WLR_XDG_TOPLEVEL_WM_CAPABILITIES_FULLSCREEN);
 
-	LISTEN(&xdg_surface->events.destroy, &c->destroy, destroynotify);
 	LISTEN(&xdg_surface->surface->events.commit, &c->commit, commitnotify);
 	LISTEN(&xdg_surface->surface->events.map, &c->map, mapnotify);
 	LISTEN(&xdg_surface->surface->events.unmap, &c->unmap, unmapnotify);
+	LISTEN(&xdg_surface->events.destroy, &c->destroy, destroynotify);
+	LISTEN(&xdg_surface->toplevel->events.set_title, &c->set_title, updatetitle);
 	LISTEN(&xdg_surface->toplevel->events.request_fullscreen, &c->fullscreen,
 			fullscreennotify);
 	LISTEN(&xdg_surface->toplevel->events.request_maximize, &c->maximize,
 			maximizenotify);
-	LISTEN(&xdg_surface->toplevel->events.set_title, &c->set_title, updatetitle);
 }
 
 void
 createpointer(struct wlr_pointer *pointer)
 {
-	struct libinput_device *device;
-	if (wlr_input_device_is_libinput(&pointer->base)
-			&& (device = wlr_libinput_get_device_handle(&pointer->base))) {
+	if (wlr_input_device_is_libinput(&pointer->base)) {
+		struct libinput_device *libinput_device = (struct libinput_device*)
+			wlr_libinput_get_device_handle(&pointer->base);
 
-		if (libinput_device_config_tap_get_finger_count(device)) {
-			libinput_device_config_tap_set_enabled(device, tap_to_click);
-			libinput_device_config_tap_set_drag_enabled(device, tap_and_drag);
-			libinput_device_config_tap_set_drag_lock_enabled(device, drag_lock);
-			libinput_device_config_tap_set_button_map(device, button_map);
+		if (libinput_device_config_tap_get_finger_count(libinput_device)) {
+			libinput_device_config_tap_set_enabled(libinput_device, tap_to_click);
+			libinput_device_config_tap_set_drag_enabled(libinput_device, tap_and_drag);
+			libinput_device_config_tap_set_drag_lock_enabled(libinput_device, drag_lock);
+			libinput_device_config_tap_set_button_map(libinput_device, button_map);
 		}
 
-		if (libinput_device_config_scroll_has_natural_scroll(device))
-			libinput_device_config_scroll_set_natural_scroll_enabled(device, natural_scrolling);
+		if (libinput_device_config_scroll_has_natural_scroll(libinput_device))
+			libinput_device_config_scroll_set_natural_scroll_enabled(libinput_device, natural_scrolling);
 
-		if (libinput_device_config_dwt_is_available(device))
-			libinput_device_config_dwt_set_enabled(device, disable_while_typing);
+		if (libinput_device_config_dwt_is_available(libinput_device))
+			libinput_device_config_dwt_set_enabled(libinput_device, disable_while_typing);
 
-		if (libinput_device_config_left_handed_is_available(device))
-			libinput_device_config_left_handed_set(device, left_handed);
+		if (libinput_device_config_left_handed_is_available(libinput_device))
+			libinput_device_config_left_handed_set(libinput_device, left_handed);
 
-		if (libinput_device_config_middle_emulation_is_available(device))
-			libinput_device_config_middle_emulation_set_enabled(device, middle_button_emulation);
+		if (libinput_device_config_middle_emulation_is_available(libinput_device))
+			libinput_device_config_middle_emulation_set_enabled(libinput_device, middle_button_emulation);
 
-		if (libinput_device_config_scroll_get_methods(device) != LIBINPUT_CONFIG_SCROLL_NO_SCROLL)
-			libinput_device_config_scroll_set_method (device, scroll_method);
+		if (libinput_device_config_scroll_get_methods(libinput_device) != LIBINPUT_CONFIG_SCROLL_NO_SCROLL)
+			libinput_device_config_scroll_set_method (libinput_device, scroll_method);
 
-		if (libinput_device_config_click_get_methods(device) != LIBINPUT_CONFIG_CLICK_METHOD_NONE)
-			libinput_device_config_click_set_method (device, click_method);
+		if (libinput_device_config_click_get_methods(libinput_device) != LIBINPUT_CONFIG_CLICK_METHOD_NONE)
+			libinput_device_config_click_set_method (libinput_device, click_method);
 
-		if (libinput_device_config_send_events_get_modes(device))
-			libinput_device_config_send_events_set_mode(device, send_events_mode);
+		if (libinput_device_config_send_events_get_modes(libinput_device))
+			libinput_device_config_send_events_set_mode(libinput_device, send_events_mode);
 
-		if (libinput_device_config_accel_is_available(device)) {
-			libinput_device_config_accel_set_profile(device, accel_profile);
-			libinput_device_config_accel_set_speed(device, accel_speed);
+		if (libinput_device_config_accel_is_available(libinput_device)) {
+			libinput_device_config_accel_set_profile(libinput_device, accel_profile);
+			libinput_device_config_accel_set_speed(libinput_device, accel_speed);
 		}
 	}
 
 	wlr_cursor_attach_input_device(cursor, &pointer->base);
 }
 
-void
-createpointerconstraint(struct wl_listener *listener, void *data)
-{
-	PointerConstraint *pointer_constraint = ecalloc(1, sizeof(*pointer_constraint));
-	pointer_constraint->constraint = data;
-	LISTEN(&pointer_constraint->constraint->events.destroy,
-			&pointer_constraint->destroy, destroypointerconstraint);
-}
-
-void
-cursorconstrain(struct wlr_pointer_constraint_v1 *constraint)
-{
-	if (active_constraint == constraint)
-		return;
-
-	if (active_constraint)
-		wlr_pointer_constraint_v1_send_deactivated(active_constraint);
-
-	active_constraint = constraint;
-	wlr_pointer_constraint_v1_send_activated(constraint);
-}
-
 void
 cursorframe(struct wl_listener *listener, void *data)
 {
@@ -1065,36 +1205,12 @@ cursorframe(struct wl_listener *listener, void *data)
 	wlr_seat_pointer_notify_frame(seat);
 }
 
-void
-cursorwarptohint(void)
-{
-	Client *c = NULL;
-	double sx = active_constraint->current.cursor_hint.x;
-	double sy = active_constraint->current.cursor_hint.y;
-
-	toplevel_from_wlr_surface(active_constraint->surface, &c, NULL);
-	/* TODO: wlroots 0.18: https://gitlab.freedesktop.org/wlroots/wlroots/-/merge_requests/4478 */
-	if (c && (active_constraint->current.committed & WLR_POINTER_CONSTRAINT_V1_STATE_CURSOR_HINT )) {
-		wlr_cursor_warp(cursor, NULL, sx + c->geom.x + c->bw, sy + c->geom.y + c->bw);
-		wlr_seat_pointer_warp(active_constraint->seat, sx, sy);
-	}
-}
-
-void
-destroydecoration(struct wl_listener *listener, void *data)
-{
-	Client *c = wl_container_of(listener, c, destroy_decoration);
-
-	wl_list_remove(&c->destroy_decoration.link);
-	wl_list_remove(&c->set_decoration_mode.link);
-}
-
 void
 destroydragicon(struct wl_listener *listener, void *data)
 {
 	/* Focus enter isn't sent during drag, so refocus the focused node. */
 	focusclient(focustop(selmon), 1);
-	motionnotify(0, NULL, 0, 0, 0, 0);
+	motionnotify(0);
 }
 
 void
@@ -1108,16 +1224,15 @@ destroyidleinhibitor(struct wl_listener *listener, void *data)
 void
 destroylayersurfacenotify(struct wl_listener *listener, void *data)
 {
-	LayerSurface *l = wl_container_of(listener, l, destroy);
+	LayerSurface *layersurface = wl_container_of(listener, layersurface, destroy);
 
-	wl_list_remove(&l->link);
-	wl_list_remove(&l->destroy.link);
-	wl_list_remove(&l->map.link);
-	wl_list_remove(&l->unmap.link);
-	wl_list_remove(&l->surface_commit.link);
-	wlr_scene_node_destroy(&l->scene->node);
-	wlr_scene_node_destroy(&l->popups->node);
-	free(l);
+	wl_list_remove(&layersurface->link);
+	wl_list_remove(&layersurface->destroy.link);
+	wl_list_remove(&layersurface->map.link);
+	wl_list_remove(&layersurface->unmap.link);
+	wl_list_remove(&layersurface->surface_commit.link);
+	wlr_scene_node_destroy(&layersurface->scene->node);
+	free(layersurface);
 }
 
 void
@@ -1130,7 +1245,7 @@ destroylock(SessionLock *lock, int unlock)
 	wlr_scene_node_set_enabled(&locked_bg->node, 0);
 
 	focusclient(focustop(selmon), 0);
-	motionnotify(0, NULL, 0, 0, 0, 0);
+	motionnotify(0);
 
 destroy:
 	wl_list_remove(&lock->new_surface.link);
@@ -1189,20 +1304,6 @@ destroynotify(struct wl_listener *listener, void *data)
 	free(c);
 }
 
-void
-destroypointerconstraint(struct wl_listener *listener, void *data)
-{
-	PointerConstraint *pointer_constraint = wl_container_of(listener, pointer_constraint, destroy);
-
-	if (active_constraint == pointer_constraint->constraint) {
-		cursorwarptohint();
-		active_constraint = NULL;
-	}
-
-	wl_list_remove(&pointer_constraint->destroy.link);
-	free(pointer_constraint);
-}
-
 void
 destroysessionlock(struct wl_listener *listener, void *data)
 {
@@ -1299,7 +1400,7 @@ focusclient(Client *c, int lift)
 	}
 
 	/* Change cursor surface */
-	motionnotify(0, NULL, 0, 0, 0, 0);
+	motionnotify(0);
 
 	/* Have a client, so focus its top-level wlr_surface */
 	client_notify_enter(client_surface(c), wlr_seat_get_keyboard(seat));
@@ -1312,11 +1413,10 @@ void
 focusmon(const Arg *arg)
 {
 	int i = 0, nmons = wl_list_length(&mons);
-	if (nmons) {
+	if (nmons)
 		do /* don't switch to disabled mons */
 			selmon = dirtomon(arg->i);
 		while (!selmon->wlr_output->enabled && i++ < nmons);
-	}
 	focusclient(focustop(selmon), 1);
 }
 
@@ -1325,7 +1425,7 @@ focusstack(const Arg *arg)
 {
 	/* Focus the next or previous client (in tiling order) on selmon */
 	Client *c, *sel = focustop(selmon);
-	if (!sel || (sel->isfullscreen && !client_has_children(sel)))
+	if (!sel || sel->isfullscreen)
 		return;
 	if (arg->i > 0) {
 		wl_list_for_each(c, &sel->link, link) {
@@ -1353,10 +1453,9 @@ Client *
 focustop(Monitor *m)
 {
 	Client *c;
-	wl_list_for_each(c, &fstack, flink) {
+	wl_list_for_each(c, &fstack, flink)
 		if (VISIBLEON(c, m))
 			return c;
-	}
 	return NULL;
 }
 
@@ -1422,7 +1521,7 @@ inputdevice(struct wl_listener *listener, void *data)
 	 * there are no pointer devices, so we always include that capability. */
 	/* TODO do we actually require a cursor? */
 	caps = WL_SEAT_CAPABILITY_POINTER;
-	if (!wl_list_empty(&kb_group.wlr_group->devices))
+	if (!wl_list_empty(&keyboards))
 		caps |= WL_SEAT_CAPABILITY_KEYBOARD;
 	wlr_seat_set_capabilities(seat, caps);
 }
@@ -1435,15 +1534,16 @@ keybinding(uint32_t mods, xkb_keysym_t sym)
 	 * processing keys, rather than passing them on to the client for its own
 	 * processing.
 	 */
+	int handled = 0;
 	const Key *k;
 	for (k = keys; k < END(keys); k++) {
-		if (CLEANMASK(mods) == CLEANMASK(k->mod)
-				&& sym == k->keysym && k->func) {
+		if (CLEANMASK(mods) == CLEANMASK(k->mod) &&
+				sym == k->keysym && k->func) {
 			k->func(&k->arg);
-			return 1;
+			handled = 1;
 		}
 	}
-	return 0;
+	return handled;
 }
 
 void
@@ -1451,7 +1551,7 @@ keypress(struct wl_listener *listener, void *data)
 {
 	int i;
 	/* This event is raised when a key is pressed or released. */
-	KeyboardGroup *group = wl_container_of(listener, group, key);
+	Keyboard *kb = wl_container_of(listener, kb, key);
 	struct wlr_keyboard_key_event *event = data;
 
 	/* Translate libinput keycode -> xkbcommon */
@@ -1459,38 +1559,37 @@ keypress(struct wl_listener *listener, void *data)
 	/* Get a list of keysyms based on the keymap for this keyboard */
 	const xkb_keysym_t *syms;
 	int nsyms = xkb_state_key_get_syms(
-			group->wlr_group->keyboard.xkb_state, keycode, &syms);
+			kb->wlr_keyboard->xkb_state, keycode, &syms);
 
 	int handled = 0;
-	uint32_t mods = wlr_keyboard_get_modifiers(&group->wlr_group->keyboard);
+	uint32_t mods = wlr_keyboard_get_modifiers(kb->wlr_keyboard);
 
 	wlr_idle_notifier_v1_notify_activity(idle_notifier, seat);
 
 	/* On _press_ if there is no active screen locker,
 	 * attempt to process a compositor keybinding. */
-	if (!locked && event->state == WL_KEYBOARD_KEY_STATE_PRESSED) {
+	if (!locked && event->state == WL_KEYBOARD_KEY_STATE_PRESSED)
 		for (i = 0; i < nsyms; i++)
 			handled = keybinding(mods, syms[i]) || handled;
-	}
 
-	if (handled && group->wlr_group->keyboard.repeat_info.delay > 0) {
-		group->mods = mods;
-		group->keysyms = syms;
-		group->nsyms = nsyms;
-		wl_event_source_timer_update(group->key_repeat_source,
-				group->wlr_group->keyboard.repeat_info.delay);
+	if (handled && kb->wlr_keyboard->repeat_info.delay > 0) {
+		kb->mods = mods;
+		kb->keysyms = syms;
+		kb->nsyms = nsyms;
+		wl_event_source_timer_update(kb->key_repeat_source,
+				kb->wlr_keyboard->repeat_info.delay);
 	} else {
-		group->nsyms = 0;
-		wl_event_source_timer_update(group->key_repeat_source, 0);
+		kb->nsyms = 0;
+		wl_event_source_timer_update(kb->key_repeat_source, 0);
 	}
 
 	if (handled)
 		return;
 
-	wlr_seat_set_keyboard(seat, &group->wlr_group->keyboard);
 	/* Pass unhandled keycodes along to the client. */
+	wlr_seat_set_keyboard(seat, kb->wlr_keyboard);
 	wlr_seat_keyboard_notify_key(seat, event->time_msec,
-			event->keycode, event->state);
+		event->keycode, event->state);
 }
 
 void
@@ -1498,27 +1597,32 @@ keypressmod(struct wl_listener *listener, void *data)
 {
 	/* This event is raised when a modifier key, such as shift or alt, is
 	 * pressed. We simply communicate this to the client. */
-	KeyboardGroup *group = wl_container_of(listener, group, modifiers);
-
-	wlr_seat_set_keyboard(seat, &group->wlr_group->keyboard);
+	Keyboard *kb = wl_container_of(listener, kb, modifiers);
+	/*
+	 * A seat can only have one keyboard, but this is a limitation of the
+	 * Wayland protocol - not wlroots. We assign all connected keyboards to the
+	 * same seat. You can swap out the underlying wlr_keyboard like this and
+	 * wlr_seat handles this transparently.
+	 */
+	wlr_seat_set_keyboard(seat, kb->wlr_keyboard);
 	/* Send modifiers to the client. */
 	wlr_seat_keyboard_notify_modifiers(seat,
-			&group->wlr_group->keyboard.modifiers);
+		&kb->wlr_keyboard->modifiers);
 }
 
 int
 keyrepeat(void *data)
 {
-	KeyboardGroup *group = data;
+	Keyboard *kb = data;
 	int i;
-	if (!group->nsyms || group->wlr_group->keyboard.repeat_info.rate <= 0)
+	if (!kb->nsyms || kb->wlr_keyboard->repeat_info.rate <= 0)
 		return 0;
 
-	wl_event_source_timer_update(group->key_repeat_source,
-			1000 / group->wlr_group->keyboard.repeat_info.rate);
+	wl_event_source_timer_update(kb->key_repeat_source,
+			1000 / kb->wlr_keyboard->repeat_info.rate);
 
-	for (i = 0; i < group->nsyms; i++)
-		keybinding(group->mods, group->keysyms[i]);
+	for (i = 0; i < kb->nsyms; i++)
+		keybinding(kb->mods, kb->keysyms[i]);
 
 	return 0;
 }
@@ -1558,15 +1662,15 @@ locksession(struct wl_listener *listener, void *data)
 void
 maplayersurfacenotify(struct wl_listener *listener, void *data)
 {
-	motionnotify(0, NULL, 0, 0, 0, 0);
+	LayerSurface *l = wl_container_of(listener, l, map);
+	motionnotify(0);
 }
 
 void
 mapnotify(struct wl_listener *listener, void *data)
 {
 	/* Called when the surface is mapped, or ready to display on-screen. */
-	Client *p = NULL;
-	Client *w, *c = wl_container_of(listener, c, map);
+	Client *p, *w, *c = wl_container_of(listener, c, map);
 	Monitor *m;
 	int i;
 
@@ -1578,14 +1682,13 @@ mapnotify(struct wl_listener *listener, void *data)
 			: wlr_scene_subsurface_tree_create(c->scene, client_surface(c));
 	c->scene->node.data = c->scene_surface->node.data = c;
 
-	client_get_geometry(c, &c->geom);
-
 	/* Handle unmanaged clients first so we can return prior create borders */
 	if (client_is_unmanaged(c)) {
+		client_get_geometry(c, &c->geom);
 		/* Unmanaged clients always are floating */
 		wlr_scene_node_reparent(&c->scene->node, layers[LyrFloat]);
 		wlr_scene_node_set_position(&c->scene->node, c->geom.x + borderpx,
-				c->geom.y + borderpx);
+			c->geom.y + borderpx);
 		if (client_wants_focus(c)) {
 			focusclient(c, 1);
 			exclusive_focus = c;
@@ -1594,13 +1697,13 @@ mapnotify(struct wl_listener *listener, void *data)
 	}
 
 	for (i = 0; i < 4; i++) {
-		c->border[i] = wlr_scene_rect_create(c->scene, 0, 0,
-				c->isurgent ? urgentcolor : bordercolor);
+		c->border[i] = wlr_scene_rect_create(c->scene, 0, 0, bordercolor);
 		c->border[i]->node.data = c;
 	}
 
 	/* Initialize client geometry with room for border */
 	client_set_tiled(c, WLR_EDGE_TOP | WLR_EDGE_BOTTOM | WLR_EDGE_LEFT | WLR_EDGE_RIGHT);
+	client_get_geometry(c, &c->geom);
 	c->geom.width += 2 * c->bw;
 	c->geom.height += 2 * c->bw;
 
@@ -1612,8 +1715,10 @@ mapnotify(struct wl_listener *listener, void *data)
 	 * we always consider floating, clients that have parent and thus
 	 * we set the same tags and monitor than its parent, if not
 	 * try to apply rules for them */
-	if ((p = client_get_parent(c))) {
+	 /* TODO: https://github.com/djpohly/dwl/pull/334#issuecomment-1330166324 */
+	if (c->type == XDGShell && (p = client_get_parent(c))) {
 		c->isfloating = 1;
+		wlr_scene_node_reparent(&c->scene->node, layers[LyrFloat]);
 		setmon(c, p->mon, p->tags);
 	} else {
 		applyrules(c);
@@ -1622,10 +1727,9 @@ mapnotify(struct wl_listener *listener, void *data)
 
 unset_fullscreen:
 	m = c->mon ? c->mon : xytomon(c->geom.x, c->geom.y);
-	wl_list_for_each(w, &clients, link) {
-		if (w != c && w != p && w->isfullscreen && m == w->mon && (w->tags & c->tags))
+	wl_list_for_each(w, &clients, link)
+		if (w != c && w->isfullscreen && m == w->mon && (w->tags & c->tags))
 			setfullscreen(w, 0);
-	}
 }
 
 void
@@ -1640,7 +1744,7 @@ maximizenotify(struct wl_listener *listener, void *data)
 	 * protocol version
 	 * wlr_xdg_surface_schedule_configure() is used to send an empty reply. */
 	Client *c = wl_container_of(listener, c, maximize);
-	if (wl_resource_get_version(c->surface.xdg->toplevel->resource)
+	if (wl_resource_get_version(c->surface.xdg->resource)
 			< XDG_TOPLEVEL_WM_CAPABILITIES_SINCE_VERSION)
 		wlr_xdg_surface_schedule_configure(c->surface.xdg);
 }
@@ -1673,53 +1777,21 @@ motionabsolute(struct wl_listener *listener, void *data)
 	 * so we have to warp the mouse there. There is also some hardware which
 	 * emits these events. */
 	struct wlr_pointer_motion_absolute_event *event = data;
-	double lx, ly, dx, dy;
-
-	if (!event->time_msec) /* this is 0 with virtual pointers */
-		wlr_cursor_warp_absolute(cursor, &event->pointer->base, event->x, event->y);
-
-	wlr_cursor_absolute_to_layout_coords(cursor, &event->pointer->base, event->x, event->y, &lx, &ly);
-	dx = lx - cursor->x;
-	dy = ly - cursor->y;
-	motionnotify(event->time_msec, &event->pointer->base, dx, dy, dx, dy);
+	wlr_cursor_warp_absolute(cursor, &event->pointer->base, event->x, event->y);
+	motionnotify(event->time_msec);
 }
 
 void
-motionnotify(uint32_t time, struct wlr_input_device *device, double dx, double dy,
-		double dx_unaccel, double dy_unaccel)
+motionnotify(uint32_t time)
 {
-	double sx = 0, sy = 0, sx_confined, sy_confined;
+	double sx = 0, sy = 0;
 	Client *c = NULL, *w = NULL;
 	LayerSurface *l = NULL;
+	int type;
 	struct wlr_surface *surface = NULL;
-	struct wlr_pointer_constraint_v1 *constraint;
 
 	/* time is 0 in internal calls meant to restore pointer focus. */
 	if (time) {
-		wlr_relative_pointer_manager_v1_send_relative_motion(
-				relative_pointer_mgr, seat, (uint64_t)time * 1000,
-				dx, dy, dx_unaccel, dy_unaccel);
-
-		wl_list_for_each(constraint, &pointer_constraints->constraints, link)
-			cursorconstrain(constraint);
-
-		if (active_constraint && cursor_mode != CurResize && cursor_mode != CurMove) {
-			toplevel_from_wlr_surface(active_constraint->surface, &c, NULL);
-			if (c && active_constraint->surface == seat->pointer_state.focused_surface) {
-				sx = cursor->x - c->geom.x - c->bw;
-				sy = cursor->y - c->geom.y - c->bw;
-				if (wlr_region_confine(&active_constraint->region, sx, sy,
-						sx + dx, sy + dy, &sx_confined, &sy_confined)) {
-					dx = sx_confined - sx;
-					dy = sy_confined - sy;
-				}
-
-				if (active_constraint->type == WLR_POINTER_CONSTRAINT_V1_LOCKED)
-					return;
-			}
-		}
-
-		wlr_cursor_move(cursor, device, dx, dy);
 		wlr_idle_notifier_v1_notify_activity(idle_notifier, seat);
 
 		/* Update selmon (even while dragging a window) */
@@ -1728,29 +1800,31 @@ motionnotify(uint32_t time, struct wlr_input_device *device, double dx, double d
 	}
 
 	/* Update drag icon's position */
-	wlr_scene_node_set_position(&drag_icon->node, ROUND(cursor->x), ROUND(cursor->y));
+	wlr_scene_node_set_position(&drag_icon->node, cursor->x, cursor->y);
 
 	/* If we are currently grabbing the mouse, handle and return */
 	if (cursor_mode == CurMove) {
 		/* Move the grabbed client to the new position. */
-		resize(grabc, (struct wlr_box){.x = ROUND(cursor->x) - grabcx, .y = ROUND(cursor->y) - grabcy,
+		resize(grabc, (struct wlr_box){.x = cursor->x - grabcx, .y = cursor->y - grabcy,
 			.width = grabc->geom.width, .height = grabc->geom.height}, 1);
 		return;
 	} else if (cursor_mode == CurResize) {
 		resize(grabc, (struct wlr_box){.x = grabc->geom.x, .y = grabc->geom.y,
-			.width = ROUND(cursor->x) - grabc->geom.x, .height = ROUND(cursor->y) - grabc->geom.y}, 1);
+			.width = cursor->x - grabc->geom.x, .height = cursor->y - grabc->geom.y}, 1);
 		return;
 	}
 
 	/* Find the client under the pointer and send the event along. */
 	xytonode(cursor->x, cursor->y, &surface, &c, NULL, &sx, &sy);
 
-	if (cursor_mode == CurPressed && !seat->drag && surface != held_grab
-			&& toplevel_from_wlr_surface(held_grab, &w, &l) >= 0) {
-		c = w;
-		surface = held_grab;
-		sx = cursor->x - (l ? l->geom.x : w->geom.x);
-		sy = cursor->y - (l ? l->geom.y : w->geom.y);
+	if (cursor_mode == CurPressed && !seat->drag) {
+		if ((type = toplevel_from_wlr_surface(
+				 seat->pointer_state.focused_surface, &w, &l)) >= 0) {
+			c = w;
+			surface = seat->pointer_state.focused_surface;
+			sx = cursor->x - (type == LayerShell ? l->geom.x : w->geom.x);
+			sy = cursor->y - (type == LayerShell ? l->geom.y : w->geom.y);
+		}
 	}
 
 	/* If there's no client surface under the cursor, set the cursor image to a
@@ -1773,8 +1847,8 @@ motionrelative(struct wl_listener *listener, void *data)
 	 * special configuration applied for the specific input device which
 	 * generated the event. You can pass NULL for the device if you want to move
 	 * the cursor around without any input. */
-	motionnotify(event->time_msec, &event->pointer->base, event->delta_x, event->delta_y,
-			event->unaccel_dx, event->unaccel_dy);
+	wlr_cursor_move(cursor, &event->pointer->base, event->delta_x, event->delta_y);
+	motionnotify(event->time_msec);
 }
 
 void
@@ -1790,8 +1864,8 @@ moveresize(const Arg *arg)
 	setfloating(grabc, 1);
 	switch (cursor_mode = arg->ui) {
 	case CurMove:
-		grabcx = ROUND(cursor->x) - grabc->geom.x;
-		grabcy = ROUND(cursor->y) - grabc->geom.y;
+		grabcx = cursor->x - grabc->geom.x;
+		grabcy = cursor->y - grabc->geom.y;
 		wlr_cursor_set_xcursor(cursor, cursor_mgr, "fleur");
 		break;
 	case CurResize:
@@ -1827,17 +1901,14 @@ outputmgrapplyortest(struct wlr_output_configuration_v1 *config, int test)
 	wl_list_for_each(config_head, &config->heads, link) {
 		struct wlr_output *wlr_output = config_head->state.output;
 		Monitor *m = wlr_output->data;
-		struct wlr_output_state state;
 
-		wlr_output_state_init(&state);
-		wlr_output_state_set_enabled(&state, config_head->state.enabled);
+		wlr_output_enable(wlr_output, config_head->state.enabled);
 		if (!config_head->state.enabled)
 			goto apply_or_test;
-
 		if (config_head->state.mode)
-			wlr_output_state_set_mode(&state, config_head->state.mode);
+			wlr_output_set_mode(wlr_output, config_head->state.mode);
 		else
-			wlr_output_state_set_custom_mode(&state,
+			wlr_output_set_custom_mode(wlr_output,
 					config_head->state.custom_mode.width,
 					config_head->state.custom_mode.height,
 					config_head->state.custom_mode.refresh);
@@ -1847,16 +1918,18 @@ outputmgrapplyortest(struct wlr_output_configuration_v1 *config, int test)
 		if (m->m.x != config_head->state.x || m->m.y != config_head->state.y)
 			wlr_output_layout_add(output_layout, wlr_output,
 					config_head->state.x, config_head->state.y);
-		wlr_output_state_set_transform(&state, config_head->state.transform);
-		wlr_output_state_set_scale(&state, config_head->state.scale);
-		wlr_output_state_set_adaptive_sync_enabled(&state,
+		wlr_output_set_transform(wlr_output, config_head->state.transform);
+		wlr_output_set_scale(wlr_output, config_head->state.scale);
+		wlr_output_enable_adaptive_sync(wlr_output,
 				config_head->state.adaptive_sync_enabled);
 
 apply_or_test:
-		ok &= test ? wlr_output_test_state(wlr_output, &state)
-				: wlr_output_commit_state(wlr_output, &state);
-
-		wlr_output_state_finish(&state);
+		if (test) {
+			ok &= wlr_output_test(wlr_output);
+			wlr_output_rollback(wlr_output);
+		} else {
+			ok &= wlr_output_commit(wlr_output);
+		}
 	}
 
 	if (ok)
@@ -1881,9 +1954,9 @@ pointerfocus(Client *c, struct wlr_surface *surface, double sx, double sy,
 		uint32_t time)
 {
 	struct timespec now;
+	int internal_call = !time;
 
-	if ((!active_constraint || active_constraint->surface != surface) &&
-			sloppyfocus && time && c && !client_is_unmanaged(c))
+	if (sloppyfocus && !internal_call && c && !client_is_unmanaged(c))
 		focusclient(c, 0);
 
 	/* If surface is NULL, clear pointer focus */
@@ -1892,7 +1965,7 @@ pointerfocus(Client *c, struct wlr_surface *surface, double sx, double sy,
 		return;
 	}
 
-	if (!time) {
+	if (internal_call) {
 		clock_gettime(CLOCK_MONOTONIC, &now);
 		time = now.tv_sec * 1000 + now.tv_nsec / 1000000;
 	}
@@ -1902,6 +1975,7 @@ pointerfocus(Client *c, struct wlr_surface *surface, double sx, double sy,
 	 * wlroots makes this a no-op if surface is already focused */
 	wlr_seat_pointer_notify_enter(seat, surface, sx, sy);
 	wlr_seat_pointer_notify_motion(seat, time, sx, sy);
+
 }
 
 void
@@ -1926,8 +2000,8 @@ printstatus(void)
 			appid = client_get_appid(c);
 			printf("%s title %s\n", m->wlr_output->name, title ? title : broken);
 			printf("%s appid %s\n", m->wlr_output->name, appid ? appid : broken);
-			printf("%s fullscreen %d\n", m->wlr_output->name, c->isfullscreen);
-			printf("%s floating %d\n", m->wlr_output->name, c->isfloating);
+			printf("%s fullscreen %u\n", m->wlr_output->name, c->isfullscreen);
+			printf("%s floating %u\n", m->wlr_output->name, c->isfloating);
 			sel = c->tags;
 		} else {
 			printf("%s title \n", m->wlr_output->name);
@@ -1938,8 +2012,8 @@ printstatus(void)
 		}
 
 		printf("%s selmon %u\n", m->wlr_output->name, m == selmon);
-		printf("%s tags %"PRIu32" %"PRIu32" %"PRIu32" %"PRIu32"\n",
-			m->wlr_output->name, occ, m->tagset[m->seltags], sel, urg);
+		printf("%s tags %u %u %u %u\n", m->wlr_output->name, occ, m->tagset[m->seltags],
+				sel, urg);
 		printf("%s layout %s\n", m->wlr_output->name, m->ltsymbol);
 	}
 	fflush(stdout);
@@ -1964,10 +2038,9 @@ rendermon(struct wl_listener *listener, void *data)
 
 	/* Render if no XDG clients have an outstanding resize and are visible on
 	 * this monitor. */
-	wl_list_for_each(c, &clients, link) {
+	wl_list_for_each(c, &clients, link)
 		if (c->resize && !c->isfloating && client_is_rendered_on_mon(c, m) && !client_is_stopped(c))
 			goto skip;
-	}
 
 	/*
 	 * HACK: The "correct" way to set the gamma is to commit it together with
@@ -1978,8 +2051,7 @@ rendermon(struct wl_listener *listener, void *data)
 	 * the gamma can not be committed).
 	 */
 	if (m->gamma_lut_changed) {
-		gamma_control
-				= wlr_gamma_control_manager_v1_get_control(gamma_control_mgr, m->wlr_output);
+		gamma_control = wlr_gamma_control_manager_v1_get_control(gamma_control_mgr, m->wlr_output);
 		m->gamma_lut_changed = 0;
 
 		if (!wlr_gamma_control_v1_apply(gamma_control, &pending))
@@ -2003,14 +2075,6 @@ skip:
 	wlr_output_state_finish(&pending);
 }
 
-void
-requestdecorationmode(struct wl_listener *listener, void *data)
-{
-	Client *c = wl_container_of(listener, c, set_decoration_mode);
-	wlr_xdg_toplevel_decoration_v1_set_mode(c->decoration,
-			WLR_XDG_TOPLEVEL_DECORATION_V1_MODE_SERVER_SIDE);
-}
-
 void
 requeststartdrag(struct wl_listener *listener, void *data)
 {
@@ -2141,19 +2205,17 @@ setcursorshape(struct wl_listener *listener, void *data)
 	 * use the provided cursor shape. */
 	if (event->seat_client == seat->pointer_state.focused_client)
 		wlr_cursor_set_xcursor(cursor, cursor_mgr,
-				wlr_cursor_shape_v1_name(event->shape));
+							   wlr_cursor_shape_v1_name(event->shape));
 }
 
 void
 setfloating(Client *c, int floating)
 {
-	Client *p = client_get_parent(c);
 	c->isfloating = floating;
 	if (!c->mon)
 		return;
-	wlr_scene_node_reparent(&c->scene->node, layers[c->isfullscreen ||
-			(p && p->isfullscreen) ? LyrFS
-			: c->isfloating ? LyrFloat : LyrTile]);
+	wlr_scene_node_reparent(&c->scene->node, layers[c->isfullscreen
+			? LyrFS : c->isfloating ? LyrFloat : LyrTile]);
 	arrange(c->mon);
 	printstatus();
 }
@@ -2186,8 +2248,6 @@ setgamma(struct wl_listener *listener, void *data)
 {
 	struct wlr_gamma_control_manager_v1_set_gamma_event *event = data;
 	Monitor *m = event->output->data;
-	if (!m)
-		return;
 	m->gamma_lut_changed = 1;
 	wlr_output_schedule_frame(m->wlr_output);
 }
@@ -2214,7 +2274,7 @@ setmfact(const Arg *arg)
 
 	if (!arg || !selmon || !selmon->lt[selmon->sellt]->arrange)
 		return;
-	f = arg->f < 1.0f ? arg->f + selmon->mfact : arg->f - 1.0f;
+	f = arg->f < 1.0 ? arg->f + selmon->mfact : arg->f - 1.0;
 	if (f < 0.1 || f > 0.9)
 		return;
 	selmon->mfact = f;
@@ -2269,14 +2329,11 @@ setsel(struct wl_listener *listener, void *data)
 void
 setup(void)
 {
-	struct xkb_context *context;
-	struct xkb_keymap *keymap;
-
 	int i, sig[] = {SIGCHLD, SIGINT, SIGTERM, SIGPIPE};
 	struct sigaction sa = {.sa_flags = SA_RESTART, .sa_handler = handlesig};
 	sigemptyset(&sa.sa_mask);
 
-	for (i = 0; i < (int)LENGTH(sig); i++)
+	for (i = 0; i < LENGTH(sig); i++)
 		sigaction(sig[i], &sa, NULL);
 
 	wlr_log_init(log_level, NULL);
@@ -2294,7 +2351,6 @@ setup(void)
 
 	/* Initialize the scene graph used to lay out windows */
 	scene = wlr_scene_create();
-	root_bg = wlr_scene_rect_create(&scene->tree, 0, 0, rootcolor);
 	for (i = 0; i < NUM_LAYERS; i++)
 		layers[i] = wlr_scene_tree_create(&scene->tree);
 	drag_icon = wlr_scene_tree_create(&scene->tree);
@@ -2386,7 +2442,7 @@ setup(void)
 	wl_signal_add(&session_lock_mgr->events.new_lock, &lock_listener);
 	LISTEN_STATIC(&session_lock_mgr->events.destroy, destroysessionmgr);
 	locked_bg = wlr_scene_rect_create(layers[LyrBlock], sgeom.width, sgeom.height,
-			(float [4]){0.1f, 0.1f, 0.1f, 1.0f});
+			(float [4]){0.1, 0.1, 0.1, 1.0});
 	wlr_scene_node_set_enabled(&locked_bg->node, 0);
 
 	/* Use decoration protocols to negotiate server-side decorations */
@@ -2396,11 +2452,6 @@ setup(void)
 	xdg_decoration_mgr = wlr_xdg_decoration_manager_v1_create(dpy);
 	LISTEN_STATIC(&xdg_decoration_mgr->events.new_toplevel_decoration, createdecoration);
 
-	pointer_constraints = wlr_pointer_constraints_v1_create(dpy);
-	LISTEN_STATIC(&pointer_constraints->events.new_constraint, createpointerconstraint);
-
-	relative_pointer_mgr = wlr_relative_pointer_manager_v1_create(dpy);
-
 	/*
 	 * Creates a cursor, which is a wlroots utility for tracking the cursor
 	 * image shown on screen.
@@ -2428,6 +2479,12 @@ setup(void)
 	LISTEN_STATIC(&cursor->events.motion, motionrelative);
 	LISTEN_STATIC(&cursor->events.motion_absolute, motionabsolute);
 	LISTEN_STATIC(&cursor->events.button, buttonpress);
+	LISTEN_STATIC(&cursor->events.swipe_begin, swipe_begin);
+	LISTEN_STATIC(&cursor->events.swipe_update, swipe_update);
+	LISTEN_STATIC(&cursor->events.swipe_end, swipe_end);
+	LISTEN_STATIC(&cursor->events.pinch_begin, pinch_begin);
+	LISTEN_STATIC(&cursor->events.pinch_update, pinch_update);
+	LISTEN_STATIC(&cursor->events.pinch_end, pinch_end);
 	LISTEN_STATIC(&cursor->events.axis, axisnotify);
 	LISTEN_STATIC(&cursor->events.frame, cursorframe);
 
@@ -2440,12 +2497,11 @@ setup(void)
 	 * pointer, touch, and drawing tablet device. We also rig up a listener to
 	 * let us know when new input devices are available on the backend.
 	 */
+	wl_list_init(&keyboards);
 	LISTEN_STATIC(&backend->events.new_input, inputdevice);
 	virtual_keyboard_mgr = wlr_virtual_keyboard_manager_v1_create(dpy);
 	LISTEN_STATIC(&virtual_keyboard_mgr->events.new_virtual_keyboard, virtualkeyboard);
-	virtual_pointer_mgr = wlr_virtual_pointer_manager_v1_create(dpy);
-	LISTEN_STATIC(&virtual_pointer_mgr->events.new_virtual_pointer, virtualpointer);
-
+	pointer_gestures = wlr_pointer_gestures_v1_create(dpy);
 	seat = wlr_seat_create(dpy, "seat0");
 	LISTEN_STATIC(&seat->events.request_set_cursor, setcursor);
 	LISTEN_STATIC(&seat->events.request_set_selection, setsel);
@@ -2453,69 +2509,19 @@ setup(void)
 	LISTEN_STATIC(&seat->events.request_start_drag, requeststartdrag);
 	LISTEN_STATIC(&seat->events.start_drag, startdrag);
 
-	/*
-	 * Configures a keyboard group, which will keep track of all connected
-	 * keyboards, keep their modifier and LED states in sync, and handle
-	 * keypresses
-	 */
-	kb_group.wlr_group = wlr_keyboard_group_create();
-	kb_group.wlr_group->data = &kb_group;
-
-	/*
-	 * Virtual keyboards need to be in a different group
-	 * https://codeberg.org/dwl/dwl/issues/554
-	 */
-	vkb_group.wlr_group = wlr_keyboard_group_create();
-	vkb_group.wlr_group->data = &vkb_group;
-
-	/* Prepare an XKB keymap and assign it to the keyboard group. */
-	context = xkb_context_new(XKB_CONTEXT_NO_FLAGS);
-	if (!(keymap = xkb_keymap_new_from_names(context, &xkb_rules,
-				XKB_KEYMAP_COMPILE_NO_FLAGS)))
-		die("failed to compile keymap");
-
-	wlr_keyboard_set_keymap(&kb_group.wlr_group->keyboard, keymap);
-	wlr_keyboard_set_keymap(&vkb_group.wlr_group->keyboard, keymap);
-	xkb_keymap_unref(keymap);
-	xkb_context_unref(context);
-
-	wlr_keyboard_set_repeat_info(&kb_group.wlr_group->keyboard, repeat_rate, repeat_delay);
-	wlr_keyboard_set_repeat_info(&vkb_group.wlr_group->keyboard, repeat_rate, repeat_delay);
-
-	/* Set up listeners for keyboard events */
-	LISTEN(&kb_group.wlr_group->keyboard.events.key, &kb_group.key, keypress);
-	LISTEN(&kb_group.wlr_group->keyboard.events.modifiers, &kb_group.modifiers, keypressmod);
-	LISTEN(&vkb_group.wlr_group->keyboard.events.key, &vkb_group.key, keypress);
-	LISTEN(&vkb_group.wlr_group->keyboard.events.modifiers, &vkb_group.modifiers, keypressmod);
-
-	kb_group.key_repeat_source = wl_event_loop_add_timer(
-			wl_display_get_event_loop(dpy), keyrepeat, &kb_group);
-	vkb_group.key_repeat_source = wl_event_loop_add_timer(
-			wl_display_get_event_loop(dpy), keyrepeat, &vkb_group);
-
-	/* A seat can only have one keyboard, but this is a limitation of the
-	 * Wayland protocol - not wlroots. We assign all connected keyboards to the
-	 * same wlr_keyboard_group, which provides a single wlr_keyboard interface for
-	 * all of them. Set this combined wlr_keyboard as the seat keyboard.
-	 */
-	wlr_seat_set_keyboard(seat, &kb_group.wlr_group->keyboard);
-
 	output_mgr = wlr_output_manager_v1_create(dpy);
 	LISTEN_STATIC(&output_mgr->events.apply, outputmgrapply);
 	LISTEN_STATIC(&output_mgr->events.test, outputmgrtest);
 
 	wlr_scene_set_presentation(scene, wlr_presentation_create(dpy, backend));
 
-	/* Make sure XWayland clients don't connect to the parent X server,
-	 * e.g when running in the x11 backend or the wayland backend and the
-	 * compositor has Xwayland support */
-	unsetenv("DISPLAY");
 #ifdef XWAYLAND
 	/*
 	 * Initialise the XWayland X server.
 	 * It will be started when the first X client is started.
 	 */
-	if ((xwayland = wlr_xwayland_create(dpy, compositor, 1))) {
+	xwayland = wlr_xwayland_create(dpy, compositor, 1);
+	if (xwayland) {
 		LISTEN_STATIC(&xwayland->events.ready, xwaylandready);
 		LISTEN_STATIC(&xwayland->events.new_surface, createnotifyx11);
 
@@ -2572,8 +2578,7 @@ tagmon(const Arg *arg)
 void
 tile(Monitor *m)
 {
-	unsigned int mw, my, ty;
-	int i, n = 0;
+	unsigned int i, n = 0, mw, my, ty;
 	Client *c;
 
 	wl_list_for_each(c, &clients, link)
@@ -2583,7 +2588,7 @@ tile(Monitor *m)
 		return;
 
 	if (n > m->nmaster)
-		mw = m->nmaster ? ROUND(m->w.width * m->mfact) : 0;
+		mw = m->nmaster ? m->w.width * m->mfact : 0;
 	else
 		mw = m->w.width;
 	i = my = ty = 0;
@@ -2625,7 +2630,10 @@ toggletag(const Arg *arg)
 {
 	uint32_t newtags;
 	Client *sel = focustop(selmon);
-	if (!sel || !(newtags = sel->tags ^ (arg->ui & TAGMASK)))
+	if (!sel)
+		return;
+	newtags = sel->tags ^ (arg->ui & TAGMASK);
+	if (!newtags)
 		return;
 
 	sel->tags = newtags;
@@ -2637,8 +2645,9 @@ toggletag(const Arg *arg)
 void
 toggleview(const Arg *arg)
 {
-	uint32_t newtagset;
-	if (!(newtagset = selmon ? selmon->tagset[selmon->seltags] ^ (arg->ui & TAGMASK) : 0))
+	uint32_t newtagset = selmon ? selmon->tagset[selmon->seltags] ^ (arg->ui & TAGMASK) : 0;
+
+	if (!newtagset)
 		return;
 
 	selmon->tagset[selmon->seltags] = newtagset;
@@ -2657,17 +2666,19 @@ unlocksession(struct wl_listener *listener, void *data)
 void
 unmaplayersurfacenotify(struct wl_listener *listener, void *data)
 {
-	LayerSurface *l = wl_container_of(listener, l, unmap);
+	LayerSurface *layersurface = wl_container_of(listener, layersurface, unmap);
 
-	l->mapped = 0;
-	wlr_scene_node_set_enabled(&l->scene->node, 0);
-	if (l == exclusive_focus)
+	layersurface->mapped = 0;
+	wlr_scene_node_set_enabled(&layersurface->scene->node, 0);
+	if (layersurface == exclusive_focus)
 		exclusive_focus = NULL;
-	if (l->layer_surface->output && (l->mon = l->layer_surface->output->data))
-		arrangelayers(l->mon);
-	if (l->layer_surface->surface == seat->keyboard_state.focused_surface)
+	if (layersurface->layer_surface->output
+			&& (layersurface->mon = layersurface->layer_surface->output->data))
+		arrangelayers(layersurface->mon);
+	if (layersurface->layer_surface->surface ==
+			seat->keyboard_state.focused_surface)
 		focusclient(focustop(selmon), 1);
-	motionnotify(0, NULL, 0, 0, 0, 0);
+	motionnotify(0);
 }
 
 void
@@ -2681,10 +2692,10 @@ unmapnotify(struct wl_listener *listener, void *data)
 	}
 
 	if (client_is_unmanaged(c)) {
-		if (c == exclusive_focus) {
+		if (c == exclusive_focus)
 			exclusive_focus = NULL;
+		if (client_surface(c) == seat->keyboard_state.focused_surface)
 			focusclient(focustop(selmon), 1);
-		}
 	} else {
 		wl_list_remove(&c->link);
 		setmon(c, NULL, 0);
@@ -2693,7 +2704,7 @@ unmapnotify(struct wl_listener *listener, void *data)
 
 	wlr_scene_node_destroy(&c->scene->node);
 	printstatus();
-	motionnotify(0, NULL, 0, 0, 0, 0);
+	motionnotify(0);
 }
 
 void
@@ -2706,8 +2717,8 @@ updatemons(struct wl_listener *listener, void *data)
 	 * positions, focus, and the stored configuration in wlroots'
 	 * output-manager implementation.
 	 */
-	struct wlr_output_configuration_v1 *config
-			= wlr_output_configuration_v1_create();
+	struct wlr_output_configuration_v1 *config =
+		wlr_output_configuration_v1_create();
 	Client *c;
 	struct wlr_output_configuration_head_v1 *config_head;
 	Monitor *m;
@@ -2721,21 +2732,17 @@ updatemons(struct wl_listener *listener, void *data)
 		/* Remove this output from the layout to avoid cursor enter inside it */
 		wlr_output_layout_remove(output_layout, m->wlr_output);
 		closemon(m);
-		m->m = m->w = (struct wlr_box){0};
+		memset(&m->m, 0, sizeof(m->m));
+		memset(&m->w, 0, sizeof(m->w));
 	}
 	/* Insert outputs that need to */
-	wl_list_for_each(m, &mons, link) {
+	wl_list_for_each(m, &mons, link)
 		if (m->wlr_output->enabled
 				&& !wlr_output_layout_get(output_layout, m->wlr_output))
 			wlr_output_layout_add_auto(output_layout, m->wlr_output);
-	}
-
 	/* Now that we update the output layout we can get its box */
 	wlr_output_layout_get_box(output_layout, NULL, &sgeom);
 
-	wlr_scene_node_set_position(&root_bg->node, sgeom.x, sgeom.y);
-	wlr_scene_rect_set_size(root_bg, sgeom.width, sgeom.height);
-
 	/* Make sure the clients are hidden when dwl is locked */
 	wlr_scene_node_set_position(&locked_bg->node, sgeom.x, sgeom.y);
 	wlr_scene_rect_set_size(locked_bg, sgeom.width, sgeom.height);
@@ -2756,7 +2763,8 @@ updatemons(struct wl_listener *listener, void *data)
 		if (m->lock_surface) {
 			struct wlr_scene_tree *scene_tree = m->lock_surface->surface->data;
 			wlr_scene_node_set_position(&scene_tree->node, m->m.x, m->m.y);
-			wlr_session_lock_surface_v1_configure(m->lock_surface, m->m.width, m->m.height);
+			wlr_session_lock_surface_v1_configure(m->lock_surface, m->m.width,
+					m->m.height);
 		}
 
 		/* Calculate the effective monitor geometry to use for clients */
@@ -2767,19 +2775,17 @@ updatemons(struct wl_listener *listener, void *data)
 		if ((c = focustop(m)) && c->isfullscreen)
 			resize(c, m->m, 0);
 
-		/* Try to re-set the gamma LUT when updating monitors,
-		 * it's only really needed when enabling a disabled output, but meh. */
 		m->gamma_lut_changed = 1;
-
+		config_head->state.enabled = 1;
+		config_head->state.mode = m->wlr_output->current_mode;
 		config_head->state.x = m->m.x;
 		config_head->state.y = m->m.y;
 	}
 
 	if (selmon && selmon->wlr_output->enabled) {
-		wl_list_for_each(c, &clients, link) {
+		wl_list_for_each(c, &clients, link)
 			if (!c->mon && client_surface(c)->mapped)
 				setmon(c, selmon, c->tags);
-		}
 		focusclient(focustop(selmon), 1);
 		if (selmon->lock_surface) {
 			client_notify_enter(selmon->lock_surface->surface,
@@ -2815,11 +2821,10 @@ urgent(struct wl_listener *listener, void *data)
 	if (!c || c == focustop(selmon))
 		return;
 
-	c->isurgent = 1;
-	printstatus();
-
 	if (client_surface(c)->mapped)
 		client_set_border_color(c, urgentcolor);
+	c->isurgent = 1;
+	printstatus();
 }
 
 void
@@ -2839,23 +2844,7 @@ void
 virtualkeyboard(struct wl_listener *listener, void *data)
 {
 	struct wlr_virtual_keyboard_v1 *keyboard = data;
-	/* Set the keymap to match the group keymap */
-	wlr_keyboard_set_keymap(&keyboard->keyboard, vkb_group.wlr_group->keyboard.keymap);
-	wlr_keyboard_set_repeat_info(&keyboard->keyboard, repeat_rate, repeat_delay);
-
-	/* Add the new keyboard to the group */
-	wlr_keyboard_group_add_keyboard(vkb_group.wlr_group, &keyboard->keyboard);
-}
-
-void
-virtualpointer(struct wl_listener *listener, void *data)
-{
-	struct wlr_virtual_pointer_v1_new_pointer_event *event = data;
-	struct wlr_pointer pointer = event->new_pointer->pointer;
-
-	wlr_cursor_attach_input_device(cursor, &pointer.base);
-	if (event->suggested_output)
-		wlr_cursor_map_input_to_output(cursor, &pointer.base, event->suggested_output);
+	createkeyboard(&keyboard->keyboard);
 }
 
 Monitor *
@@ -2906,13 +2895,12 @@ zoom(const Arg *arg)
 
 	/* Search for the first tiled window that is not sel, marking sel as
 	 * NULL if we pass it along the way */
-	wl_list_for_each(c, &clients, link) {
+	wl_list_for_each(c, &clients, link)
 		if (VISIBLEON(c, selmon) && !c->isfloating) {
 			if (c != sel)
 				break;
 			sel = NULL;
 		}
-	}
 
 	/* Return if no other tiled window was found */
 	if (&c->link == &clients)
@@ -2936,7 +2924,7 @@ activatex11(struct wl_listener *listener, void *data)
 	Client *c = wl_container_of(listener, c, activate);
 
 	/* Only "managed" windows can be activated */
-	if (!client_is_unmanaged(c))
+	if (c->type == X11Managed)
 		wlr_xwayland_surface_activate(c->surface.xwayland, 1);
 }
 
@@ -2954,15 +2942,11 @@ configurex11(struct wl_listener *listener, void *data)
 {
 	Client *c = wl_container_of(listener, c, configure);
 	struct wlr_xwayland_surface_configure_event *event = data;
-	/* TODO: figure out if there is another way to do this */
-	if (!c->mon) {
-		wlr_xwayland_surface_configure(c->surface.xwayland,
-				event->x, event->y, event->width, event->height);
+	if (!c->mon)
 		return;
-	}
-	if (c->isfloating || client_is_unmanaged(c))
+	if (c->isfloating || c->type == X11Unmanaged)
 		resize(c, (struct wlr_box){.x = event->x, .y = event->y,
-				.width = event->width + c->bw * 2, .height = event->height + c->bw * 2}, 0);
+				.width = event->width, .height = event->height}, 0);
 	else
 		arrange(c->mon);
 }
@@ -2976,18 +2960,18 @@ createnotifyx11(struct wl_listener *listener, void *data)
 	/* Allocate a Client for this surface */
 	c = xsurface->data = ecalloc(1, sizeof(*c));
 	c->surface.xwayland = xsurface;
-	c->type = X11;
+	c->type = xsurface->override_redirect ? X11Unmanaged : X11Managed;
 	c->bw = borderpx;
 
 	/* Listen to the various events it can emit */
 	LISTEN(&xsurface->events.associate, &c->associate, associatex11);
-	LISTEN(&xsurface->events.destroy, &c->destroy, destroynotify);
 	LISTEN(&xsurface->events.dissociate, &c->dissociate, dissociatex11);
 	LISTEN(&xsurface->events.request_activate, &c->activate, activatex11);
 	LISTEN(&xsurface->events.request_configure, &c->configure, configurex11);
-	LISTEN(&xsurface->events.request_fullscreen, &c->fullscreen, fullscreennotify);
 	LISTEN(&xsurface->events.set_hints, &c->set_hints, sethints);
 	LISTEN(&xsurface->events.set_title, &c->set_title, updatetitle);
+	LISTEN(&xsurface->events.destroy, &c->destroy, destroynotify);
+	LISTEN(&xsurface->events.request_fullscreen, &c->fullscreen, fullscreennotify);
 }
 
 void
@@ -3020,10 +3004,11 @@ sethints(struct wl_listener *listener, void *data)
 		return;
 
 	c->isurgent = xcb_icccm_wm_hints_get_urgency(c->surface.xwayland->hints);
-	printstatus();
 
 	if (c->isurgent && surface && surface->mapped)
 		client_set_border_color(c, urgentcolor);
+
+	printstatus();
 }
 
 void
diff --git a/gestures-diff.patch b/gestures-diff.patch
new file mode 100644
index 0000000..e0f0a4e
--- /dev/null
+++ b/gestures-diff.patch
@@ -0,0 +1,157 @@
+diff --git a/config.def.h b/config.def.h
+index db0babc..e2ec245 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -13,6 +13,8 @@ static const float urgentcolor[]           = COLOR(0xff0000ff);
+ /* To conform the xdg-protocol, set the alpha to zero to restore the old behavior */
+ static const float fullscreen_bg[]         = {0.1, 0.1, 0.1, 1.0}; /* You can also use glsl colors */
+ 
++static const unsigned int swipe_min_threshold = 0;
++
+ /* tagging - TAGCOUNT must be no greater than 31 */
+ #define TAGCOUNT (9)
+ 
+@@ -167,3 +169,10 @@ static const Button buttons[] = {
+ 	{ MODKEY, BTN_MIDDLE, togglefloating, {0} },
+ 	{ MODKEY, BTN_RIGHT,  moveresize,     {.ui = CurResize} },
+ };
++
++static const Gesture gestures[] = {
++	// { MODKEY, SWIPE_LEFT, 4, shiftview, { .i = 1 } },
++	// { MODKEY, SWIPE_RIGHT, 4, shiftview, { .i = -1 } },
++	{ MODKEY, SWIPE_UP, 3, focusstack, {.i = 1} },
++	{ MODKEY, SWIPE_DOWN, 3, focusstack, {.i = -1} },
++};
+diff --git a/dwl.c b/dwl.c
+index 2aeaca1..fd7ab00 100644
+--- a/dwl.c
++++ b/dwl.c
+@@ -81,6 +81,7 @@ enum { LyrBg, LyrBottom, LyrTile, LyrFloat, LyrFS, LyrTop, LyrOverlay, LyrBlock,
+ enum { NetWMWindowTypeDialog, NetWMWindowTypeSplash, NetWMWindowTypeToolbar,
+ 	NetWMWindowTypeUtility, NetLast }; /* EWMH atoms */
+ #endif
++enum { SWIPE_LEFT, SWIPE_RIGHT, SWIPE_DOWN, SWIPE_UP };
+ 
+ typedef union {
+ 	int i;
+@@ -96,6 +97,14 @@ typedef struct {
+ 	const Arg arg;
+ } Button;
+ 
++typedef struct {
++	unsigned int mod;
++	unsigned int motion;
++	unsigned int fingers_count;
++	void (*func)(const Arg *);
++	const Arg arg;
++} Gesture;
++
+ typedef struct Monitor Monitor;
+ typedef struct {
+ 	/* Must keep these three elements in this order */
+@@ -236,6 +245,7 @@ static void arrangelayer(Monitor *m, struct wl_list *list,
+ static void arrangelayers(Monitor *m);
+ static void axisnotify(struct wl_listener *listener, void *data);
+ static void buttonpress(struct wl_listener *listener, void *data);
++static int ongesture(struct wlr_pointer_swipe_end_event *event);
+ static void swipe_begin(struct wl_listener *listener, void *data);
+ static void swipe_update(struct wl_listener *listener, void *data);
+ static void swipe_end(struct wl_listener *listener, void *data);
+@@ -385,6 +395,10 @@ static struct wlr_box sgeom;
+ static struct wl_list mons;
+ static Monitor *selmon;
+ 
++static uint32_t swipe_fingers = 0;
++static double swipe_dx = 0;
++static double swipe_dy = 0;
++
+ #ifdef XWAYLAND
+ static void activatex11(struct wl_listener *listener, void *data);
+ static void associatex11(struct wl_listener *listener, void *data);
+@@ -404,6 +418,8 @@ static xcb_atom_t netatom[NetLast];
+ /* attempt to encapsulate suck into one file */
+ #include "client.h"
+ 
++static const unsigned int abzsquare = swipe_min_threshold * swipe_min_threshold;
++
+ /* function implementations */
+ void
+ applybounds(Client *c, struct wlr_box *bbox)
+@@ -610,6 +626,11 @@ swipe_begin(struct wl_listener *listener, void *data)
+ {
+ 	struct wlr_pointer_swipe_begin_event *event = data;
+ 
++	swipe_fingers = event->fingers;
++	// Reset swipe distance at the beginning of a swipe
++	swipe_dx = 0;
++	swipe_dy = 0;
++
+ 	// Forward swipe begin event to client
+ 	wlr_pointer_gestures_v1_send_swipe_begin(
+ 		pointer_gestures, 
+@@ -624,6 +645,11 @@ swipe_update(struct wl_listener *listener, void *data)
+ {
+ 	struct wlr_pointer_swipe_update_event *event = data;
+ 
++	swipe_fingers = event->fingers;
++	// Accumulate swipe distance
++	swipe_dx += event->dx;
++	swipe_dy += event->dy;
++
+ 	// Forward swipe update event to client
+ 	wlr_pointer_gestures_v1_send_swipe_update(
+ 		pointer_gestures, 
+@@ -634,11 +660,53 @@ swipe_update(struct wl_listener *listener, void *data)
+ 	);
+ }
+ 
++int
++ongesture(struct wlr_pointer_swipe_end_event *event)
++{
++	struct wlr_keyboard *keyboard;
++	uint32_t mods;
++	const Gesture *g;
++	unsigned int motion;
++	unsigned int adx = fabs(swipe_dx);
++	unsigned int ady = fabs(swipe_dy);
++	int handled = 0;
++
++	if (event->cancelled) {
++		return handled;
++	}
++
++	// Require absolute distance movement beyond a small thresh-hold
++	if (adx * adx + ady * ady < abzsquare) {
++		return handled;
++	}
++
++	if (adx > ady) {
++		motion = swipe_dx < 0 ? SWIPE_LEFT : SWIPE_RIGHT;
++	} else {
++		motion = swipe_dy < 0 ? SWIPE_UP : SWIPE_DOWN;
++	}
++
++	keyboard = wlr_seat_get_keyboard(seat);
++	mods = keyboard ? wlr_keyboard_get_modifiers(keyboard) : 0;
++	for (g = gestures; g < END(gestures); g++) {
++		if (CLEANMASK(mods) == CLEANMASK(g->mod) &&
++			 swipe_fingers == g->fingers_count &&
++			 motion == g->motion && g->func) {
++			g->func(&g->arg);
++			handled = 1;
++		}
++	}
++	return handled;
++}
++
+ void
+ swipe_end(struct wl_listener *listener, void *data)
+ {
+ 	struct wlr_pointer_swipe_end_event *event = data;
+ 
++	// TODO: should we stop here if the event has been handled?
++	ongesture(event);
++
+ 	// Forward swipe end event to client
+ 	wlr_pointer_gestures_v1_send_swipe_end(
+ 		pointer_gestures, 
diff --git a/gestures.patch b/gestures.patch
new file mode 100644
index 0000000..4f72b77
--- /dev/null
+++ b/gestures.patch
@@ -0,0 +1,173 @@
+From a68af2e251dcc0cccef32a3cbbbe44481ed32576 Mon Sep 17 00:00:00 2001
+From: wochap <gean.marroquin@gmail.com>
+Date: Wed, 6 Mar 2024 10:35:18 -0500
+Subject: [PATCH] add swipe gestures to trigger functions
+
+like libinput-gestures, it supports the following gestures: SWIPE_UP, SWIPE_DOWN, SWIPE_LEFT and SWIPE_RIGHT
+support multiple fingers count in gestures[]
+support mods in gestures[]
+---
+ config.def.h |  9 +++++++
+ dwl.c        | 68 ++++++++++++++++++++++++++++++++++++++++++++++++++++
+ 2 files changed, 77 insertions(+)
+
+diff --git a/config.def.h b/config.def.h
+index db0babc..e2ec245 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -13,6 +13,8 @@ static const float urgentcolor[]           = COLOR(0xff0000ff);
+ /* To conform the xdg-protocol, set the alpha to zero to restore the old behavior */
+ static const float fullscreen_bg[]         = {0.1, 0.1, 0.1, 1.0}; /* You can also use glsl colors */
+ 
++static const unsigned int swipe_min_threshold = 0;
++
+ /* tagging - TAGCOUNT must be no greater than 31 */
+ #define TAGCOUNT (9)
+ 
+@@ -167,3 +169,10 @@ static const Button buttons[] = {
+ 	{ MODKEY, BTN_MIDDLE, togglefloating, {0} },
+ 	{ MODKEY, BTN_RIGHT,  moveresize,     {.ui = CurResize} },
+ };
++
++static const Gesture gestures[] = {
++	// { MODKEY, SWIPE_LEFT, 4, shiftview, { .i = 1 } },
++	// { MODKEY, SWIPE_RIGHT, 4, shiftview, { .i = -1 } },
++	{ MODKEY, SWIPE_UP, 3, focusstack, {.i = 1} },
++	{ MODKEY, SWIPE_DOWN, 3, focusstack, {.i = -1} },
++};
+diff --git a/dwl.c b/dwl.c
+index 2aeaca1..fd7ab00 100644
+--- a/dwl.c
++++ b/dwl.c
+@@ -81,6 +81,7 @@ enum { LyrBg, LyrBottom, LyrTile, LyrFloat, LyrFS, LyrTop, LyrOverlay, LyrBlock,
+ enum { NetWMWindowTypeDialog, NetWMWindowTypeSplash, NetWMWindowTypeToolbar,
+ 	NetWMWindowTypeUtility, NetLast }; /* EWMH atoms */
+ #endif
++enum { SWIPE_LEFT, SWIPE_RIGHT, SWIPE_DOWN, SWIPE_UP };
+ 
+ typedef union {
+ 	int i;
+@@ -96,6 +97,14 @@ typedef struct {
+ 	const Arg arg;
+ } Button;
+ 
++typedef struct {
++	unsigned int mod;
++	unsigned int motion;
++	unsigned int fingers_count;
++	void (*func)(const Arg *);
++	const Arg arg;
++} Gesture;
++
+ typedef struct Monitor Monitor;
+ typedef struct {
+ 	/* Must keep these three elements in this order */
+@@ -236,6 +245,7 @@ static void arrangelayer(Monitor *m, struct wl_list *list,
+ static void arrangelayers(Monitor *m);
+ static void axisnotify(struct wl_listener *listener, void *data);
+ static void buttonpress(struct wl_listener *listener, void *data);
++static int ongesture(struct wlr_pointer_swipe_end_event *event);
+ static void swipe_begin(struct wl_listener *listener, void *data);
+ static void swipe_update(struct wl_listener *listener, void *data);
+ static void swipe_end(struct wl_listener *listener, void *data);
+@@ -385,6 +395,10 @@ static struct wlr_box sgeom;
+ static struct wl_list mons;
+ static Monitor *selmon;
+ 
++static uint32_t swipe_fingers = 0;
++static double swipe_dx = 0;
++static double swipe_dy = 0;
++
+ #ifdef XWAYLAND
+ static void activatex11(struct wl_listener *listener, void *data);
+ static void associatex11(struct wl_listener *listener, void *data);
+@@ -404,6 +418,8 @@ static xcb_atom_t netatom[NetLast];
+ /* attempt to encapsulate suck into one file */
+ #include "client.h"
+ 
++static const unsigned int abzsquare = swipe_min_threshold * swipe_min_threshold;
++
+ /* function implementations */
+ void
+ applybounds(Client *c, struct wlr_box *bbox)
+@@ -610,6 +626,11 @@ swipe_begin(struct wl_listener *listener, void *data)
+ {
+ 	struct wlr_pointer_swipe_begin_event *event = data;
+ 
++	swipe_fingers = event->fingers;
++	// Reset swipe distance at the beginning of a swipe
++	swipe_dx = 0;
++	swipe_dy = 0;
++
+ 	// Forward swipe begin event to client
+ 	wlr_pointer_gestures_v1_send_swipe_begin(
+ 		pointer_gestures, 
+@@ -624,6 +645,11 @@ swipe_update(struct wl_listener *listener, void *data)
+ {
+ 	struct wlr_pointer_swipe_update_event *event = data;
+ 
++	swipe_fingers = event->fingers;
++	// Accumulate swipe distance
++	swipe_dx += event->dx;
++	swipe_dy += event->dy;
++
+ 	// Forward swipe update event to client
+ 	wlr_pointer_gestures_v1_send_swipe_update(
+ 		pointer_gestures, 
+@@ -634,11 +660,53 @@ swipe_update(struct wl_listener *listener, void *data)
+ 	);
+ }
+ 
++int
++ongesture(struct wlr_pointer_swipe_end_event *event)
++{
++	struct wlr_keyboard *keyboard;
++	uint32_t mods;
++	const Gesture *g;
++	unsigned int motion;
++	unsigned int adx = fabs(swipe_dx);
++	unsigned int ady = fabs(swipe_dy);
++	int handled = 0;
++
++	if (event->cancelled) {
++		return handled;
++	}
++
++	// Require absolute distance movement beyond a small thresh-hold
++	if (adx * adx + ady * ady < abzsquare) {
++		return handled;
++	}
++
++	if (adx > ady) {
++		motion = swipe_dx < 0 ? SWIPE_LEFT : SWIPE_RIGHT;
++	} else {
++		motion = swipe_dy < 0 ? SWIPE_UP : SWIPE_DOWN;
++	}
++
++	keyboard = wlr_seat_get_keyboard(seat);
++	mods = keyboard ? wlr_keyboard_get_modifiers(keyboard) : 0;
++	for (g = gestures; g < END(gestures); g++) {
++		if (CLEANMASK(mods) == CLEANMASK(g->mod) &&
++			 swipe_fingers == g->fingers_count &&
++			 motion == g->motion && g->func) {
++			g->func(&g->arg);
++			handled = 1;
++		}
++	}
++	return handled;
++}
++
+ void
+ swipe_end(struct wl_listener *listener, void *data)
+ {
+ 	struct wlr_pointer_swipe_end_event *event = data;
+ 
++	// TODO: should we stop here if the event has been handled?
++	ongesture(event);
++
+ 	// Forward swipe end event to client
+ 	wlr_pointer_gestures_v1_send_swipe_end(
+ 		pointer_gestures, 
+-- 
+2.42.0
+
diff --git a/pointer-gestures-unstable-v1.patch b/pointer-gestures-unstable-v1.patch
new file mode 100644
index 0000000..0ece12a
--- /dev/null
+++ b/pointer-gestures-unstable-v1.patch
@@ -0,0 +1,149 @@
+diff --git a/dwl.c b/dwl.c
+index ef27a1d..2aeaca1 100644
+--- a/dwl.c
++++ b/dwl.c
+@@ -34,6 +34,7 @@
+ #include <wlr/types/wlr_output_layout.h>
+ #include <wlr/types/wlr_output_management_v1.h>
+ #include <wlr/types/wlr_pointer.h>
++#include <wlr/types/wlr_pointer_gestures_v1.h>
+ #include <wlr/types/wlr_presentation_time.h>
+ #include <wlr/types/wlr_primary_selection.h>
+ #include <wlr/types/wlr_primary_selection_v1.h>
+@@ -235,6 +236,12 @@ static void arrangelayer(Monitor *m, struct wl_list *list,
+ static void arrangelayers(Monitor *m);
+ static void axisnotify(struct wl_listener *listener, void *data);
+ static void buttonpress(struct wl_listener *listener, void *data);
++static void swipe_begin(struct wl_listener *listener, void *data);
++static void swipe_update(struct wl_listener *listener, void *data);
++static void swipe_end(struct wl_listener *listener, void *data);
++static void pinch_begin(struct wl_listener *listener, void *data);
++static void pinch_update(struct wl_listener *listener, void *data);
++static void pinch_end(struct wl_listener *listener, void *data);
+ static void chvt(const Arg *arg);
+ static void checkidleinhibitor(struct wlr_surface *exclude);
+ static void cleanup(void);
+@@ -357,6 +364,7 @@ static struct wlr_output_manager_v1 *output_mgr;
+ static struct wlr_gamma_control_manager_v1 *gamma_control_mgr;
+ static struct wlr_virtual_keyboard_manager_v1 *virtual_keyboard_mgr;
+ static struct wlr_cursor_shape_manager_v1 *cursor_shape_mgr;
++static struct wlr_pointer_gestures_v1 *pointer_gestures;
+ 
+ static struct wlr_cursor *cursor;
+ static struct wlr_xcursor_manager *cursor_mgr;
+@@ -597,6 +605,94 @@ buttonpress(struct wl_listener *listener, void *data)
+ 			event->time_msec, event->button, event->state);
+ }
+ 
++void
++swipe_begin(struct wl_listener *listener, void *data)
++{
++	struct wlr_pointer_swipe_begin_event *event = data;
++
++	// Forward swipe begin event to client
++	wlr_pointer_gestures_v1_send_swipe_begin(
++		pointer_gestures, 
++		seat,
++		event->time_msec,
++		event->fingers
++	);
++}
++
++void
++swipe_update(struct wl_listener *listener, void *data)
++{
++	struct wlr_pointer_swipe_update_event *event = data;
++
++	// Forward swipe update event to client
++	wlr_pointer_gestures_v1_send_swipe_update(
++		pointer_gestures, 
++		seat,
++		event->time_msec,
++		event->dx,
++		event->dy
++	);
++}
++
++void
++swipe_end(struct wl_listener *listener, void *data)
++{
++	struct wlr_pointer_swipe_end_event *event = data;
++
++	// Forward swipe end event to client
++	wlr_pointer_gestures_v1_send_swipe_end(
++		pointer_gestures, 
++		seat,
++		event->time_msec,
++		event->cancelled
++	);
++}
++
++void
++pinch_begin(struct wl_listener *listener, void *data)
++{
++	struct wlr_pointer_pinch_begin_event *event = data;
++
++	// Forward pinch begin event to client
++	wlr_pointer_gestures_v1_send_pinch_begin(
++		pointer_gestures, 
++		seat,
++		event->time_msec,
++		event->fingers
++	);
++}
++
++void
++pinch_update(struct wl_listener *listener, void *data)
++{
++	struct wlr_pointer_pinch_update_event *event = data;
++
++	// Forward pinch update event to client
++	wlr_pointer_gestures_v1_send_pinch_update(
++		pointer_gestures,
++		seat,
++		event->time_msec,
++		event->dx,
++		event->dy,
++		event->scale,
++		event->rotation
++	);
++}
++
++void
++pinch_end(struct wl_listener *listener, void *data)
++{
++	struct wlr_pointer_pinch_end_event *event = data;
++
++	// Forward pinch end event to client
++	wlr_pointer_gestures_v1_send_pinch_end(
++		pointer_gestures,
++		seat,
++		event->time_msec,
++		event->cancelled
++	);
++}
++
+ void
+ chvt(const Arg *arg)
+ {
+@@ -2315,6 +2411,12 @@ setup(void)
+ 	LISTEN_STATIC(&cursor->events.motion, motionrelative);
+ 	LISTEN_STATIC(&cursor->events.motion_absolute, motionabsolute);
+ 	LISTEN_STATIC(&cursor->events.button, buttonpress);
++	LISTEN_STATIC(&cursor->events.swipe_begin, swipe_begin);
++	LISTEN_STATIC(&cursor->events.swipe_update, swipe_update);
++	LISTEN_STATIC(&cursor->events.swipe_end, swipe_end);
++	LISTEN_STATIC(&cursor->events.pinch_begin, pinch_begin);
++	LISTEN_STATIC(&cursor->events.pinch_update, pinch_update);
++	LISTEN_STATIC(&cursor->events.pinch_end, pinch_end);
+ 	LISTEN_STATIC(&cursor->events.axis, axisnotify);
+ 	LISTEN_STATIC(&cursor->events.frame, cursorframe);
+ 
+@@ -2331,6 +2433,7 @@ setup(void)
+ 	LISTEN_STATIC(&backend->events.new_input, inputdevice);
+ 	virtual_keyboard_mgr = wlr_virtual_keyboard_manager_v1_create(dpy);
+ 	LISTEN_STATIC(&virtual_keyboard_mgr->events.new_virtual_keyboard, virtualkeyboard);
++	pointer_gestures = wlr_pointer_gestures_v1_create(dpy);
+ 	seat = wlr_seat_create(dpy, "seat0");
+ 	LISTEN_STATIC(&seat->events.request_set_cursor, setcursor);
+ 	LISTEN_STATIC(&seat->events.request_set_selection, setsel);
